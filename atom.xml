<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杜若喃呢</title>
  <subtitle>山中人兮芳杜若</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://duruonanni.com/"/>
  <updated>2018-01-21T10:45:02.856Z</updated>
  <id>http://duruonanni.com/</id>
  
  <author>
    <name>Xiangyu Kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub入门与实践读书笔记</title>
    <link href="http://duruonanni.com/git-summary/20180121.html"/>
    <id>http://duruonanni.com/git-summary/20180121.html</id>
    <published>2018-01-21T10:34:55.000Z</published>
    <updated>2018-01-21T10:45:02.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><ul>
<li>本文是杜若学习GitHub的笔记整理,主要参考了以下书籍,博客:<ol>
<li><a href="http://www.ituring.com.cn/book/1581" title="图灵出版社 &lt;GitHub入门与实践&gt;" target="_blank" rel="external"><github入门与实践></github入门与实践></a></li>
<li><a href="https://liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰先生的git教程</a></li>
<li><a href="https://git-scm.com/book/zh/v2" title="Por Git 官方教程" target="_blank" rel="external">Por Git</a> (推荐,官方教程)</li>
</ol>
</li>
<li>由于我的开发环境是<code>Windows</code>,所以主要记录这上面的使用方法<ul>
<li>PS: 为了添加操作对应的图片,基本重写了整个笔记,真是够了</li>
</ul>
</li>
<li>在笔记的末尾,总结了笔记示例中用到的<a href="#git_command">常用Git命令</a>,供以查询<ul>
<li>笔记只涉及Git和Github的概念性介绍,和简单的Git命令</li>
<li>更多厉害的功能,我也还不会,待以后扩充吧<br>呐~正文开始啦~🐱‍👤</li>
</ul>
</li>
</ul>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199203:/github_portal.png?authkey=AJoh90nl3u6Wj4U" alt="github_portal"></div>

<hr>
<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介:"></a>Git简介:</h2><ul>
<li>Git是一种分布式版本控制系统</li>
<li>作用是可以将文件的改动进行记录和保存</li>
<li>还能与多人共享同一项目,同步每个人改动的记录,方便的实现多人开发</li>
<li>区别于<code>Subversion</code>集中式的管理,Git使用的分布式可以实现每个成员都拥有完整的版本库<ul>
<li>多人协作时只将修改部分同步给对方</li>
<li>这样就算某个成员数据丢失,耶不会影响整个项目的数据</li>
</ul>
</li>
<li>Git的开发者是大名鼎鼎的Linus,就是开发Linux的那位大神</li>
<li>GitHub,就是一个使用Git系统的网络仓库,开发者可以将自己的代码提交上去,并使用Git进行方便的管理操作 </li>
</ul>
<h3 id="Git暂存区"><a href="#Git暂存区" class="headerlink" title="Git暂存区"></a><a href="#staged">Git暂存区</a></h3><!-- <span id="staged">Git暂存区</span> -->
<ul>
<li>Git的暂存区是一个很优秀的设计,在这里大概介绍一下</li>
<li>使用Git进行版本控制,同步的实际上是文件的改动</li>
<li>在默认状况下,所有文件的改动会先存放到一特殊区域<code>暂存区</code></li>
<li>在需要回滚之前的版本时,通过<code>HEAD</code>指针指向需要的版本<ul>
<li>可以迅速的提取准确出需要的版本,而且并不暂用大量空间</li>
</ul>
</li>
<li>在Win系统中,仓库文件夹中有隐藏文件<code>.git</code><ul>
<li><code>.git</code>文件夹下存放着暂存区和版本库分支</li>
<li>文件的变化,首先要纳入暂存区中,再通过<code>commit</code>提交到版本库分支</li>
</ul>
</li>
<li>注意事项:<ul>
<li>Git版本控制系统,只能识别文本文件的具体改动,如txt文件,代码等</li>
<li>其他类型文件,照片,视频等,是二进制文件,可以知道文件大小的变化,却无法识别具体改动<ul>
<li>特别是word也是二进制格式的,所以无法跟踪word文件的改动</li>
<li>GitHub使用是免费的,人家维护也很不容易,不要把照片和视频这样的大文件放在GitHub上面啊喂,这不是网盘</li>
<li>GitHub上的代码是公开的,别想把银行卡账号密码也放上去啊喂</li>
<li>使用的文件编码,最好统一为<code>UTF-8</code>避免冲突  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Git中文件的三种状态"><a href="#Git中文件的三种状态" class="headerlink" title="Git中文件的三种状态:"></a>Git中文件的三种状态:</h3><p>在Git仓库中,文件拥有三种状态,这里大概介绍下: </p>
<ol>
<li><code>commit</code> : 已提交<ul>
<li>表示数据已经安全的保存在本地仓库中了</li>
</ul>
</li>
<li><code>modified</code> : 已修改<ul>
<li>表示数据发生变化,但还未保存到本地仓库中</li>
</ul>
</li>
<li><code>staged</code> : 已暂存<ul>
<li>表示数据的变化存入了<a href="#staged">暂存区</a>,但还未保存到仓库中</li>
</ul>
</li>
</ol>
<hr>
<h2 id="GitHub简介"><a href="#GitHub简介" class="headerlink" title="GitHub简介:"></a>GitHub简介:</h2><ul>
<li>Github相当于一个Git的远程公开服务器<ul>
<li>可以把自己的代码上传到Github上,并进行版本管理</li>
<li>当然,GitHub的能力远不止管理代码版本<ul>
<li>可以使用私有仓库,要给GitHub钱</li>
<li>私有仓库也可以自己租服务器,架Git仓库</li>
</ul>
</li>
</ul>
</li>
<li><p>GitHub的标志很萌,叫<code>octocat</code>–&gt; <code>octopus</code>+<code>cat</code></p>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199201:/octocat.png?authkey=AJoh90nl3u6Wj4U" alt="octocat"></div>
</li>
<li><p>GitHub上绝大多数都是公开的代码,这影响了人们的开发方式</p>
<ul>
<li>GitHub提出了<code>Social Coding</code>,社会化编程的概念</li>
<li>任何人可以都拷贝别人的代码进行审核或学习</li>
<li>也可以直接像开发者指出错误,和提出改进方案</li>
<li>甚至可以直接将自己改好的代码提交给开发者,并由开发者合并到源码中</li>
<li>Github还提供了<code>Issue</code>功能,用于相互讨论<ul>
<li>GitHub的评论支持Markdown语法,这一定程度上推进了MD的普及</li>
</ul>
</li>
<li>提供了<code>WiKi</code>功能,用于开发者描述项目</li>
<li><code>Pull Request</code>功能,用于向别人仓库提出申请,将自己修改的代码合并到别人项目中</li>
<li>总之,GitHub让全世界程序员联系在了一起,成为了程序员的乐园 </li>
</ul>
</li>
</ul>
<hr>
<h2 id="Git在Windows下的安装和初始化"><a href="#Git在Windows下的安装和初始化" class="headerlink" title="Git在Windows下的安装和初始化"></a>Git在Windows下的安装和初始化</h2><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><ul>
<li><code>Git</code>下载地址:<ul>
<li><code>https://git-scm.com/downloads</code></li>
<li>按照安装提示进行安装即可</li>
<li>如果已安装,需要更新<code>Git</code>版本,就在<code>Git Bash</code>中输入<ul>
<li><code>git clone https://github.com/git/git</code></li>
</ul>
</li>
</ul>
</li>
<li>安装好后,会出现一个<code>Git Bash</code>应用<ul>
<li>这是一个命令提示符界面,类似CMD</li>
<li>所有的Git命令都在这个应用中使用 <div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199205:/Git_Bash.png?authkey=AJoh90nl3u6Wj4U" alt="Git_Bash"></div>

</li>
</ul>
</li>
</ul>
<h3 id="Git初始设置"><a href="#Git初始设置" class="headerlink" title="Git初始设置"></a>Git初始设置</h3><ul>
<li>设置Git用户名和邮箱<ul>
<li><code>git config --global user.name &quot;Firstname Lastname</code></li>
<li><code>git config --global user.email &quot;your_email@example.com</code></li>
<li><code>--global</code>表示该配置对这台电脑所有有文件夹都有效</li>
<li>设置完成,会在<code>C:\user\当前用户\.gitconfig</code>下生成本地的配置文件<ul>
<li>该配置文件中记录了当前用户的仓库路径等参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GitHub的注册"><a href="#GitHub的注册" class="headerlink" title="GitHub的注册"></a>GitHub的注册</h3><ul>
<li>官网在此: <code>https://github.com/</code><ul>
<li>进去注册就行啦 </li>
</ul>
</li>
</ul>
<h3 id="SSH-Key的作用"><a href="#SSH-Key的作用" class="headerlink" title="SSH Key的作用"></a>SSH Key的作用</h3><h4 id="SSH-Key简介"><a href="#SSH-Key简介" class="headerlink" title="SSH Key简介"></a>SSH Key简介</h4><ul>
<li>Git是支持SSH协议的,GitHub通过<code>SSH Key</code>识别推送人,所以需要进行设置<ul>
<li>简言之,<code>SSH Key</code>是连接GitHub仓库时认证用的 </li>
</ul>
</li>
</ul>
<h4 id="SSH-Key生成"><a href="#SSH-Key生成" class="headerlink" title="SSH Key生成"></a>SSH Key生成</h4><ul>
<li>在本地电脑的<code>Git Bash</code>软件中执行:<ul>
<li><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code><ul>
<li>邮箱改成自己的</li>
<li>后面步骤一路回车就是了</li>
<li>可以不用设置密码</li>
</ul>
</li>
</ul>
</li>
<li>执行完毕后,在当前用户目录下,会生成一个<code>.ssh</code>目录<ul>
<li>点进去可以看到<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件</li>
<li><code>id_rsa.pub</code>是公开密钥;<code>id_rsa</code>是私有密钥 </li>
</ul>
</li>
</ul>
<h4 id="向GitHub添加公钥用于连接"><a href="#向GitHub添加公钥用于连接" class="headerlink" title="向GitHub添加公钥用于连接"></a>向GitHub添加公钥用于连接</h4><ul>
<li>登陆GitHub,找到<code>setting</code>–&gt;<code>SSH Keys and GPG Keys</code>  <div align="center">![git_SSH_Key13]</div></li>
<li>选<code>Add SSH Key</code><ul>
<li>title填你喜欢的</li>
<li>Key填刚才生成的公有密钥<code>id_rsa.pub</code>中的值</li>
</ul>
</li>
<li>点<code>ADD Key</code>进行添加</li>
<li>注意:<ul>
<li>这个Key对应的是这台电脑和你的账号</li>
<li>如果有多台电脑使用这个账号,需要生成多个Key,并添加到GitHub中 </li>
</ul>
</li>
</ul>
<hr>
<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><ul>
<li>这些命令都是基于Linux的,有Linux命令行基础会更好</li>
<li>下面是正文: </li>
</ul>
<h3 id="创建本地版本库-init"><a href="#创建本地版本库-init" class="headerlink" title="创建本地版本库 : init"></a>创建本地版本库 : <code>init</code></h3><ul>
<li>具体用法<ol>
<li>选中一个文件夹,用<code>Git Bash</code>输入<code>git init</code><ul>
<li>后面凡是命令输入都是在<code>Git Bash</code>中使用,不再赘述</li>
<li>可以在选中文件夹使用鼠标右键,选中<code>Git Bash</code>再输入命令</li>
<li>也可以打开<code>Git Bash</code>应用,使用<code>cd</code>命令进入到选中的文件夹中</li>
</ul>
</li>
<li>使用<code>git status</code>查看该仓库状态,是否创建成功</li>
</ol>
</li>
<li>说明:<ul>
<li>本地版本库是一个文件夹</li>
<li>创建完成后,该文件夹会多出一个<code>.git</code>隐藏子目录</li>
<li>Git就是利用这个子目录来跟踪和管理版本库的,所以不要去动它</li>
</ul>
</li>
</ul>
<h3 id="向本地仓库添加-amp-提交文件-add-amp-commit"><a href="#向本地仓库添加-amp-提交文件-add-amp-commit" class="headerlink" title="向本地仓库添加&amp;提交文件 : add&amp;commit"></a>向本地仓库添加&amp;提交文件 : <code>add</code>&amp;<code>commit</code></h3><ul>
<li><p>具体用法</p>
<ol>
<li><p>在本地仓库(就是<code>init</code>的那个文件夹)中,创建一个简单文本文件<code>hello_world.php</code>,文件里面写上:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?php</span></span></div><div class="line"><span class="keyword">echo</span> <span class="string">"Hello World"</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用命令: <code>git add hello_world.php</code></p>
<ul>
<li>类似事务管理,这样做只是缓存了<code>add</code>这个动作,还没有正式执行</li>
<li>所以,可以执行多次<code>add</code>之后,再统一进行<code>commit</code></li>
</ul>
</li>
<li>使用命令: <code>git commit -m &quot;...&quot;</code><ul>
<li>commit执行后,之前的<code>add</code>命令才被执行</li>
<li><code>-m</code>后面的语句是对执行这次<code>commit</code>动作的说明,用于解释本次操作的作用<ul>
<li>说明是非常重要的,可以通过<code>git log</code>查看,多人协作中,别人也会容易的知道你执行了什么 </li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="版本控制基本用法1-修改文件"><a href="#版本控制基本用法1-修改文件" class="headerlink" title="版本控制基本用法1 : 修改文件"></a>版本控制基本用法1 : 修改文件</h3><ul>
<li>具体用法:<ol>
<li>向之前的<code>hello_world.php</code>添加一句注释,<code>&lt;!-- 添加注释 --&gt;</code><ul>
<li>此时这个文件中的数据就已经改变了</li>
<li>可以通过<code>git status</code>命令查看文件状态,会显示<code>modified</code> <div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201522:/git_diff.png?authkey=AJoh90nl3u6Wj4U" alt="git_diff"></div></li>
</ul>
</li>
<li>执行<code>git diff 文件名</code>命令<ul>
<li>diff就是different的简写,注意后面要加文件名</li>
<li>执行后会显示该文件的未提交的具体变化 </li>
<li>添加的注释是绿色的,前面有个<code>+</code><div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201523:/git_status.png?authkey=AJoh90nl3u6Wj4U" alt="git_status"></div></li>
</ul>
</li>
<li>执行<code>git add 文件名</code>命令<ul>
<li>将修改后的结果提交到仓库中</li>
<li>注意每次修改了,必须要执行<code>add</code>,再<code>commit</code>才能纳入仓库</li>
</ul>
</li>
<li>执行<code>git commit -m &quot;add annotation&quot;</code>命令<ul>
<li>让修改生效,纳入到仓库中</li>
<li>这样原文件和文件的修改都纳入仓库中,后面需要就可以再退回修改前的原文件,达到了版本控制的效果</li>
</ul>
</li>
<li>执行<code>git status</code>查看当前文件状态<ul>
<li>会看到之前没有需要提交的修改了</li>
<li><code>working three is clean</code><div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201525:/github7.png?authkey=AJoh90nl3u6Wj4U" alt="github7"></div></li>
</ul>
</li>
<li>建议多次尝试修改,进行练习 </li>
</ol>
</li>
</ul>
<h3 id="版本控制基本用法2-退回之前版本"><a href="#版本控制基本用法2-退回之前版本" class="headerlink" title="版本控制基本用法2 : 退回之前版本"></a>版本控制基本用法2 : 退回之前版本</h3><ul>
<li>具体用法:<ol>
<li>执行<code>git log</code>命令<ul>
<li>查看仓库日志,就是<code>commit</code>的执行和说明<ul>
<li>日志中<code>commit</code>后面的一串字符是系统生成的id</li>
<li>用来标识那次改动的版本<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201527:/git_log9.png?authkey=AJoh90nl3u6Wj4U" alt="git_log9"></div></li>
</ul>
</li>
<li>多次提交<code>commit</code>Git会把执行存成一条时间线</li>
<li>通过<code>Git Gui</code>可以查看提交历史的时间线<ul>
<li>不建议使用这个软件,因为我们主要会在<code>github</code>上看啦<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201526:/github_GitGui8.png?authkey=AJoh90nl3u6Wj4U" alt="github_GitGui8"></div></li>
</ul>
</li>
<li>在<code>Git Bash</code>中查看完日志后的退出<ul>
<li>方式1: 输入<code>q</code>再回车</li>
<li>方式2: 输入<code>ctrl c</code><ul>
<li>方式2,我写了后有bug,界面不显示我输入的字了,要重启<code>Git Bash</code></li>
<li>还是用方式1吧</li>
</ul>
</li>
<li>这是常见的<code>Linux</code>命令,有时间再去整理<code>Linux</code>的笔记</li>
</ul>
</li>
</ul>
</li>
<li>执行<code>git reset --hard HEAD^</code><ul>
<li>退回上一版本<ul>
<li>Git中,HEAD用于表示当前版本,上一版本用<code>HEAD^</code>表示</li>
<li>同理,上上一版本写成<code>HEAD^^</code>,上一百个版本写成<code>HEAD~100</code></li>
<li>也可以通过<code>log</code>查看<code>commit</code>后面的id号,用id号替代<code>HEAD^</code>进行精确的退回</li>
<li><code>--hard</code>:<ul>
<li>Git有三种恢复等级<code>soft</code>,<code>mixed</code>(默认),<code>hard</code></li>
<li>其中<code>hard</code>是一种不可逆的操作</li>
</ul>
</li>
</ul>
</li>
<li>退回后,再去打开之前的<code>hello_world.php</code>文件看看<ul>
<li>是不是退回到修改之前的文本了</li>
</ul>
</li>
</ul>
</li>
<li>在此恢复到修改之后的操作<ul>
<li>只要找到当时修改操作的<code>commit</code>后面的id号,就能恢复</li>
<li>找id号,可以执行<code>git log</code>找对应的id号</li>
<li>也可以执行,<code>git reflog</code>,找到需要退回到哪次<code>HEAD</code>上<ul>
<li>这个命令可以找到之前的每一次<code>commit</code>记录</li>
</ul>
</li>
<li>注意哈:<ul>
<li>找<code>commit</code>的id,是通过你每次提交时写的提交信息来找的</li>
<li>所以,提交信息非常重要,要写清楚,方便自己找</li>
</ul>
</li>
<li>找到对应的id号后,执行<ul>
<li><code>git reset --hard 版本号</code></li>
<li>或者<code>git reset --hard HEAD^</code> 退回几次就用几个<code>^</code>符号</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>注意事项:<ul>
<li>对文件的修改,需要执行<code>add</code>命令才算纳入了暂存区</li>
<li>所以,要注意以下描述中的错误操作<ol>
<li>对文件进行修改(修改1)</li>
<li>使用<code>add</code>命令将此次修改纳入到暂存区</li>
<li>再对文件进行修改(修改2)</li>
<li>使用<code>commit</code>命令将修改提交到版本库中</li>
</ol>
</li>
<li>结果,(修改2)不会被提交到版本库中,而且通过<code>status</code>命令,会看到该文件有一次修改(modified)未被提交</li>
<li>原因是(修改2)没有通过<code>add</code>纳入修改到暂存区</li>
<li>结论:<ul>
<li>要确保每次修改生效,就要记得纳入暂存区</li>
<li>最好所有修改都执行了再操作Git,防止变化没有提交版本库 </li>
</ul>
</li>
</ul>
</li>
<li>注意事项:<ul>
<li>现在还是在本地使用Git,还没有联网接入Github</li>
<li>联网接入后,推送到远程库里后,再撤销,由于分支的问题,别人也会看到撤销</li>
<li>所以提交更改要小心啦</li>
</ul>
</li>
</ul>
<h3 id="版本控制基本用法3-commit前-撤销修改"><a href="#版本控制基本用法3-commit前-撤销修改" class="headerlink" title="版本控制基本用法3: commit前,撤销修改"></a>版本控制基本用法3: commit前,撤销修改</h3><ul>
<li>情景1: 只修改了文件,未执行git命令前,撤销具体方法:<ol>
<li>向之前的<code>hello_world.php</code>添加一句注释,<code>&lt;!-- stupid boss --&gt;</code><ul>
<li>此时,未执行<code>add</code>命令,使用<code>git status</code>查看,会发现该文件有改动(modified)待提交,我们要做的是,撤销这次改动,不向版本库提交</li>
</ul>
</li>
<li>执行<code>git checkout -- hello_world.php</code><ul>
<li>这句话的作用是将文件的当前修改撤销</li>
<li>文件如果<code>add</code>过一次修改,在未<code>commit</code>前,又修改了一次文件,使用此命令依旧有效,只要没有<code>commit</code>到版本库中就行</li>
<li>注意1:<ul>
<li><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“创建⼀一个新分⽀支”的命令，后面的分⽀支管理中会再次遇到<code>git checkout</code>命令</li>
<li>关于<code>分支</code>的介绍[后面][#branch]会讲</li>
</ul>
</li>
<li>注意2:<ul>
<li>如果修改已经<code>add</code>纳入暂存区了,使用这句命令就无效了</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>情形2: 文件的修改使用<code>add</code>纳入到了暂存区,撤销的具体方法:<ol>
<li>向之前的<code>hello_world.php</code>添加一句注释,<code>&lt;!-- stupid boss --&gt;</code></li>
<li>执行了<code>git add hello_world.php</code>命令<ul>
<li>此时查看<code>status</code>,会发现修改已添加到暂存区了</li>
<li>此时需要撤销修改</li>
</ul>
</li>
<li>执行<code>git reset HEAD hello_world.php</code><ul>
<li>看这里<code>reset</code>命令也可以撤销暂存区中的修改哈</li>
<li>现在看<code>status</code>,修改显示为未纳入暂存区的红色状态,那就用情形1的方法搞定吧<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201528:/git_reset2.png?authkey=AJoh90nl3u6Wj4U" alt="git_reset2"></div></li>
</ul>
</li>
<li>执行<code>git checkout -- hello_world.php</code></li>
</ol>
</li>
</ul>
<h3 id="版本控制基本用法3-删除文件"><a href="#版本控制基本用法3-删除文件" class="headerlink" title="版本控制基本用法3: 删除文件"></a>版本控制基本用法3: 删除文件</h3><ul>
<li>具体用法:<ol>
<li>在版本库目录下新建文件<code>hello_git.txt</code>,写一个简单的<code>Hello</code>在里面吧</li>
<li>执行<code>git add hello_git.txt</code></li>
<li>执行<code>git commit -m &quot;add hello_git.txt&quot;</code><ul>
<li>此时,新文件以纳入版本库</li>
</ul>
</li>
<li>在本地删除该文件,执行<code>git status</code><ul>
<li>信息说名该文件被删除了</li>
<li>但本地删除了,版本库里还有,需要删除版本库中的执行<code>5.</code>操作<br><div aling="center">![git_delete12]</div><ol>
<li>执行<code>git rm hello_git.txt</code></li>
</ol>
</li>
<li>删除版本库中的该文件,<code>rm --&gt; remove</code></li>
<li>此时查看<code>status</code>,可见该删除待<code>commit</code></li>
</ul>
</li>
<li>执行<code>git commit -m &quot;delete hello_git.txt</code></li>
</ol>
</li>
<li>注意: 在未执行<code>commit</code>时,想撤回删除,恢复文件,使用如下操作<ol>
<li>执行<code>git checkout -- hello_git.txt</code><ul>
<li>这样的操作实际是从版本库里取出文件进行替换</li>
<li>如果有未提交的更改未纳入版本库中,此方式会有数据的损失</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="GitHub远程仓库的使用"><a href="#GitHub远程仓库的使用" class="headerlink" title="GitHub远程仓库的使用"></a>GitHub远程仓库的使用</h2><h3 id="添加远程库-amp-与本地仓库关联"><a href="#添加远程库-amp-与本地仓库关联" class="headerlink" title="添加远程库&amp;与本地仓库关联"></a>添加远程库&amp;与本地仓库关联</h3><ul>
<li>具体做法:<ol>
<li>在GitHub上创建一个仓库<ul>
<li>点页面右上角的<code>New Repository</code></li>
<li>仓库名随便起,为了统一,都叫<code>nostalgic</code>吧<ul>
<li>听<a href="http://music.163.com/m/song?id=801824&amp;userid=9567158" target="_blank" rel="external">这首歌</a>时候取的名字…</li>
</ul>
</li>
<li>选<code>Create repository</code>确认创建<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201531:/git_new_repo14.png?authkey=AJoh90nl3u6Wj4U" alt="git_new_repo14"></div></li>
</ul>
</li>
<li>将本地仓库与GitHub上新建的仓库连接<ul>
<li>进入本地仓库,在<code>Git Bash</code>中输入:</li>
<li><code>git remote add origin git@github.com:你的帐户名/你的仓库名.git</code></li>
<li>这个操作,看GitHub上都有提醒的,复制代码来运行即可</li>
<li>操作中的<code>origin</code>,是远程库的名字,默认使用这个名字,这样看到就知道是远程库了<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201532:/git_new_repo15.png?authkey=AJoh90nl3u6Wj4U" alt="git_new_repo15"></div></li>
</ul>
</li>
<li>将本地库内容推送到GitHub远程库上<ul>
<li>执行:<code>git push -u origin master</code><ul>
<li><code>-u</code> : 将本地master分支和远程master分支关联的参数<ul>
<li>关联一次后,后面推送就不需要这个参数了</li>
</ul>
</li>
<li><code>origin</code> : 说明推送到的远程仓库的名字</li>
<li><code>master</code> : 主分支,关于分支,[后面][#branch]会详细讲<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201533:/git_push16.png?authkey=AJoh90nl3u6Wj4U" alt="git_push16"></div></li>
</ul>
</li>
</ul>
</li>
<li>打开GitHub上的<code>noastalgic</code>项目,本地仓库的内容就已经推送到了<ul>
<li>随时将本地项目<code>push</code>到GitHub上,就能防止代码丢失等情况<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201534:/github_push17.png?authkey=AJoh90nl3u6Wj4U" alt="github_push17"></div></li>
</ul>
</li>
</ol>
</li>
<li>附 : GitHub创建仓库的名词解释<ul>
<li>创建<code>Private</code>是要收费的,免费的都是公开的</li>
<li><code>Description</code> 是用于描述项目的,相当于简介,项目生成后在项目名下的小字</li>
<li><code>ReadMe</code> 一般用于标明代码概要,使用流程,许可协议等,会显示在项目首页</li>
<li><code>.gitignord</code> 添加后,里面可以放不受版本管理的文件</li>
<li><code>license</code> 选择项目使用的开源协议 </li>
</ul>
</li>
</ul>
<h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><ul>
<li>具体做法:<ol>
<li>在GitHub上创建一个新仓库,<code>ClonePractice</code><ul>
<li>勾选添加<code>READNME</code>文件</li>
</ul>
</li>
<li>选择一个本地文件夹,打开<code>Git Bash</code><ul>
<li>文件夹不要和原有仓库文件夹一样,会出错</li>
<li>执行:<code>git clone git@github.com:duruonanni/ClonePractice.git</code><ul>
<li>换成自己的仓库地址<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201535:/git_clone18.jpg?authkey=AJoh90nl3u6Wj4U" alt="git_clone18"></div><br><div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201536:/git_clone19.png?authkey=AJoh90nl3u6Wj4U" alt="git_clone19"></div></li>
</ul>
</li>
</ul>
</li>
<li>完成后,打开该文件夹,会看到一个<code>README.md</code>的文件,说明该仓库成功从Github上克隆到本地了 </li>
</ol>
</li>
</ul>
<hr>
<h2 id="GitHub分支管理"><a href="#GitHub分支管理" class="headerlink" title="GitHub分支管理"></a><span id="branch">GitHub分支管理</span></h2><h3 id="分支管理概述"><a href="#分支管理概述" class="headerlink" title="分支管理概述:"></a>分支管理概述:</h3><ul>
<li>分支管理是GitHub学习最重要的概念</li>
<li>回顾一下: <ul>
<li>我们知道,Git对版本的控制,是通过时间线记录文件内容的变化来操作的</li>
<li>每次对文件执行操作(增删改),再commit,就会在文件的版本生成一个新的时间点</li>
<li>每个时间点有自己唯一的id号,通过<code>HEAD</code>指针,可以回到任意某个时间点,从而达到对版本的控制</li>
</ul>
</li>
<li>在多端操作中:<ul>
<li>由于Git的同步方式是分布式的,这意味着,多台电脑上可以维护着同一个项目</li>
<li>每台电脑都拥有该项目的全部代码</li>
<li>那么,在不同电脑修改同意文件后进行提交,就会产生冲突</li>
<li>分支的引入就是解决这个冲突的</li>
</ul>
</li>
<li>分支:<ul>
<li>Git上存在一个主分支<code>master</code>(之前的操作都是在主分支上进行的)</li>
<li>我们可以创建其他分支,在其他分支中对代码进行修改</li>
<li>当新分支中的工作结束后,我们可以将新分支中的工作,合并(merge)入主分支中</li>
<li>在GitHub上,你可以随意的去从别人公开的代码中创建属于自己的新分支,并对上面的代码进行操作<ul>
<li>Github上代码的合并需要主分支的所有者同意(pull request)</li>
<li>所以,你可以对新分支进行任意操作,而不影响主分支的项目 </li>
</ul>
</li>
<li>Git中鼓励使用分支 </li>
</ul>
</li>
</ul>
<h3 id="分支管理的使用1-新分支的创建-合并与删除"><a href="#分支管理的使用1-新分支的创建-合并与删除" class="headerlink" title="分支管理的使用1 : 新分支的创建,合并与删除"></a>分支管理的使用1 : 新分支的创建,合并与删除</h3><ul>
<li>具体做法:<ol>
<li>在刚clone的项目<code>ClonePractice</code>本地仓库中,创建新分支:<ul>
<li>执行<code>git checkout -b dev</code><ul>
<li>意思是创建一个新分支<code>dev</code>,并切换到它</li>
<li>相当于: <code>git branch dev</code>加<code>git checkout dev</code></li>
</ul>
</li>
</ul>
</li>
<li>查看当前项目的本地分支:<ul>
<li>执行: <code>git branch</code><ul>
<li><code>*</code>表示当前所在分支<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201539:/git_master22.png?authkey=AJoh90nl3u6Wj4U" alt="git_branch20"></div></li>
</ul>
</li>
<li>执行: <code>git status</code><ul>
<li>查看项目状态,注意目前所在分支</li>
</ul>
</li>
</ul>
</li>
<li>对该项目中的文件<code>README.MD</code>进行修改并提交<ul>
<li>文件末尾添加一句:  <code>This is dev branch did</code></li>
<li>执行: <code>git add README.MD</code></li>
<li>执行: <code>git commit -m &quot;branch test&quot;</code></li>
</ul>
</li>
<li>切换回master主分支<ul>
<li>执行: <code>git checkout master</code></li>
<li>查看<code>README.MD</code>内容,是否有改变<ul>
<li>当然是没改变,在主分支并未生效</li>
</ul>
</li>
</ul>
</li>
<li>合并<code>dev</code>分支到主分支<ul>
<li>执行: <code>git merge dev</code><ul>
<li>执行的是将<code>dev</code>分支合并到当前分支,当前分支这里是<code>master</code>主分支</li>
<li>执行后显示的<code>Fast-forward</code>意思是<ul>
<li>这次合并是”快进模式”,也就是直接把master指向dev的当前提交,所以合并速度非常快</li>
<li>后面还会讲到其他合并模式<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201538:/git_merge21.png?authkey=AJoh90nl3u6Wj4U" alt="git_merge21"></div></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>删除<code>dev</code>分支<ul>
<li>执行: <code>git branch -d dev</code></li>
<li>git建议使用完成某个分支后,就删除掉 </li>
</ul>
</li>
</ol>
</li>
<li>分支的强制删除: <ul>
<li>默认情况下,分支中的内容只有被merge到其他分支后,该分支才能被顺利删除</li>
<li>如果想要抛弃某个分支中的内容,将其强制删除,使用如下命令:</li>
<li><code>git branch -D dev</code></li>
<li>注意:<ul>
<li>平时要慎重使用此删除分支的方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分支管理的使用2-解决文件冲突"><a href="#分支管理的使用2-解决文件冲突" class="headerlink" title="分支管理的使用2: 解决文件冲突"></a>分支管理的使用2: 解决文件冲突</h3><ul>
<li>操作概述:<ul>
<li>同一个文件,分支1修改了,分支2也进行了修改</li>
<li>如何解决文件被修改的冲突</li>
</ul>
</li>
<li>具体做法:<ol>
<li>创建并切换到新分支<code>feature1</code><ul>
<li>执行: <code>git checkout -b feature1</code></li>
</ul>
</li>
<li>修改<code>README.MD</code>文件<ul>
<li>最后一句改为: <code>This is feature1 did</code></li>
</ul>
</li>
<li>提交<ul>
<li>执行: <code>git add README.MD</code></li>
<li>执行: <code>git commit -m &quot;feature1 modified&quot;</code></li>
</ul>
</li>
<li>切换到master分支<ul>
<li>执行: <code>git checkout master</code><ul>
<li>显示: <code>Your branch is ahead of &#39;origin/master&#39; by 1 commit.</code><ul>
<li>说明本地的<code>master</code>分支比远程的<code>origin/maste</code>超前一个版本(<code>commit</code>)<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201539:/git_master22.png?authkey=AJoh90nl3u6Wj4U" alt="git_master22"></div></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>修改<code>README.MD</code>文件<ul>
<li>最后一句改成: <code>This is master did&quot;</code></li>
</ul>
</li>
<li>提交<ul>
<li>执行: <code>git add README.MD</code></li>
<li>执行: <code>git commit -m &quot;master modified&quot;</code></li>
</ul>
</li>
<li>尝试合并feature1分支<ul>
<li>执行: <code>git merge feature1</code></li>
<li>显示合并失败,文件冲突<code>CONFILCT</code></li>
<li>也开始在尝试合并后,使用<code>status</code>查看状态,系统有给出解决冲突的建议<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201540:/git_master23.png?authkey=AJoh90nl3u6Wj4U" alt="git_master23"></div></li>
</ul>
</li>
<li>解决文件冲突<ul>
<li>打开文件看看,文件现在变成这样了<ul>
<li><code>cat</code> 是linux命令,查看文件内容</li>
<li>也可以在编辑器中打开文件,一样的效果</li>
</ul>
</li>
<li>Git⽤用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>,<code>=======</code>,<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</li>
<li>我们可以根据需要手动对内容进行修改并保存<ul>
<li>我们只留下master的修改</li>
<li>当然在更智能的编辑器上,可以更方便的修改冲突</li>
<li>VSCODE上集成了Git,它的冲突修改界面入下图2<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201542:/git_merge_config24.png?authkey=AJoh90nl3u6Wj4U" alt="git_merge_config24"></div><br><div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201543:/git_merge_config_vscode25.png?authkey=AJoh90nl3u6Wj4U" alt="git_merge_config_vscode25"></div></li>
</ul>
</li>
</ul>
</li>
<li>提交解决冲突后的版本<ul>
<li>执行: <code>git add README.MD</code></li>
<li>执行: <code>git commit -m &quot;confict fixed&quot;</code></li>
</ul>
</li>
<li>删除无用分支feature1<ul>
<li>执行: <code>git branch -d feature1</code></li>
</ul>
</li>
<li>用log查看分支情况<ul>
<li>执行: <code>git log --graph</code></li>
<li>可以看到分支启用和合并的情况<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201544:/git_log_graph26.png?authkey=AJoh90nl3u6Wj4U" alt="git_log_graph26"></div>

</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="分支管理的使用3-分支管理策略"><a href="#分支管理的使用3-分支管理策略" class="headerlink" title="分支管理的使用3: 分支管理策略"></a>分支管理的使用3: 分支管理策略</h3><ul>
<li>操作概述: <ul>
<li>之前有讲,默认情况下,Git使用<code>merge</code>合并分支,结果是使用的<code>Fast forword</code>模式</li>
<li>这个模式,会将独立分支中的操作,归为合并后的分支,缺点就是丢掉分支信息,丢掉了之前操作是分支执行的记录了</li>
<li>可以通过禁止<code>Fast forword</code>的方式,保留分支信息</li>
<li>具体操作是再执行<code>merge</code>时,添加<code>-no-ff</code>参数</li>
<li>下面是示例: </li>
</ul>
</li>
<li>具体做法: <ol>
<li>创建并切换到,<code>dev</code>分支<ul>
<li><code>git checkout -b dev</code></li>
</ul>
</li>
<li>修改<code>README.MD</code>文件<ul>
<li>最后一句改为: <code>This is dev branch did, to test merge no-ff model</code></li>
</ul>
</li>
<li>为当前修改提交<code>add</code>和<code>commit</code><ul>
<li><code>git add README.MD</code></li>
<li><code>git commit -m &quot;update README.md</code></li>
</ul>
</li>
<li>切换回master分支<ul>
<li><code>git checkout master</code></li>
</ul>
</li>
<li>合并<code>dev</code>分支,注意<code>-no-ff</code> 参数<ul>
<li><code>git merge --no-ff -m &quot;merge dev with no-ff&quot; dev</code><div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!203845:/git_merge_no-ff27.png?authkey=AJoh90nl3u6Wj4U" alt="git_merge_no-ff27"></div></li>
</ul>
</li>
<li>使用<code>log</code>查看分支历史<ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit&quot;</code><ul>
<li><code>--pretty=oneline</code> : 让log的显示格式为简略1行</li>
<li><code>--abbrev-commit</code> : id值只显示前面几个字符</li>
<li><code>log</code>的更多查看方式,见<span id="log">下面</span><div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!203846:/git_log_no-ff28.png?authkey=AJoh90nl3u6Wj4U" alt="git_log_no-ff28"></div></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>总结: <ul>
<li>采用<code>no-ff</code>形式,分支执行的操作历史也得以保存,不会被合并</li>
<li>这样的做法,适合团队协作开发项目时使用</li>
</ul>
</li>
</ul>
<h3 id="分支管理的使用4-暂存当前工作"><a href="#分支管理的使用4-暂存当前工作" class="headerlink" title="分支管理的使用4: 暂存当前工作"></a>分支管理的使用4: 暂存当前工作</h3><ul>
<li>操作概述: <ul>
<li>git中,可以将当前未完成的工作暂存起来,以便对之前的版本进行临时修改</li>
<li>新的修改结束后,取出暂存的数据,继续进行操作</li>
<li>这样的操作,通常用于<code>Bug处理</code>时</li>
<li>暂存的关键词是<code>stash</code></li>
<li>下面来模拟操作一下: </li>
</ul>
</li>
<li>具体做法: <ol>
<li>切换到dev分支,在仓库中创建一个<code>working.txt</code>文件<ul>
<li><code>git checkout dev</code></li>
<li>创建<code>working.txt</code>文件,随便写点什么</li>
<li><code>git add working.txt</code></li>
</ul>
</li>
<li>这时候master分支有bug需要立即处理,使用<code>stash</code>将当前工作”储藏”起来<ul>
<li><code>git stash</code><div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!203847:/git_stash29.png?authkey=AJoh90nl3u6Wj4U" alt="git_stash29"></div></li>
</ul>
</li>
<li>切换到master分支,修复bug<ul>
<li><code>git checkout master</code></li>
<li>从master分支,创建修复bug的临时分支<code>issue-01</code><ul>
<li>不要直接在master上面改呀</li>
<li><code>git chekout -b issue-01</code></li>
</ul>
</li>
<li>在<code>README.md</code>末尾添加一句: <code>bug fixed</code>,并提交<ul>
<li><code>git add README.md</code></li>
<li><code>git commit -m &quot;bug fixed&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>切换回master分支,与issue-01分支合并,删除issue-01分支<ul>
<li><code>git checkout master</code></li>
<li><code>git merge --no-ff -m &quot;merged bug fix 01&quot; issue-01</code></li>
<li><code>git branch -d issue-01</code></li>
</ul>
</li>
<li>回到刚才的dev分支<ul>
<li><code>git checkout dev</code><ul>
<li>此时查看<code>status</code>,显示没有暂存的项目,文件夹里的<code>working.txt</code>也没有</li>
<li>这时候就需要将之前<code>stash</code>存储的工作恢复回来</li>
</ul>
</li>
</ul>
</li>
<li>恢复到之前的工作<ul>
<li>有两种恢复方式<ol>
<li><code>git stash apply</code><ul>
<li>恢复后,stash中的内容并不删除</li>
<li>可使用 <code>git stash drop</code>进行删除</li>
</ul>
</li>
<li><code>git stash pop</code><ul>
<li>恢复stash中的内容,并删除</li>
</ul>
</li>
</ol>
</li>
<li>可使用<code>git stash list</code>命令查看保存的stash<div aling="center"><img src="http://storage.live.com/items/AEE68C12565C1619!203848:/git_stash_pop30.png?authkey=AJoh90nl3u6Wj4U" alt="git_stash_pop30"></div>

</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="Git标签-tag-管理"><a href="#Git标签-tag-管理" class="headerlink" title="Git标签(tag)管理"></a>Git标签(tag)管理</h2><h3 id="Git标签概述"><a href="#Git标签概述" class="headerlink" title="Git标签概述"></a>Git标签概述</h3><ul>
<li>在开发和维护程序时,通常需要对程序的版本情况进行描述</li>
<li>之前的操作中,我们都使用commit操作完成后,系统提供的id号作为对版本的说明</li>
<li>此外,Git还提供了<code>标签</code>,用来更方便的描述版本号</li>
<li>比如我们通常将初次完成的项目所在的版本,用标签命名为<code>v1.0</code></li>
<li>使用标签号,我们可以方便的对版本进行说明,也可以使用标签名找到对应时刻的历史版本</li>
<li>Git中的标签是和分支上的某个版本紧密相连的 </li>
</ul>
<h3 id="Git标签操作1-标签的创建和删除"><a href="#Git标签操作1-标签的创建和删除" class="headerlink" title="Git标签操作1: 标签的创建和删除"></a>Git标签操作1: 标签的创建和删除</h3><ul>
<li>操作概述: <ul>
<li>标签操作前一定要注意查看所在的分支</li>
<li>可以对当前commit打标签,也可以对历史的commit打标签</li>
</ul>
</li>
<li>具体做法: <ol>
<li>查看当前分支,切换到<code>master</code>分支<ul>
<li><code>git branch</code></li>
<li><code>git checkout master</code></li>
</ul>
</li>
<li>对当前commit(也就是最新的)打上tag<ul>
<li><code>git tag v1.0</code></li>
</ul>
</li>
<li>查看所有标签<ul>
<li><code>git tag</code></li>
</ul>
</li>
<li>对历史commit打上tag<ul>
<li><code>git tag v0.9 4744420</code></li>
<li>后面写的是commit的版本号</li>
</ul>
</li>
<li>删除标签<ul>
<li><code>git tag -d v1.0</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Git标签操作2-远程标签操作"><a href="#Git标签操作2-远程标签操作" class="headerlink" title="Git标签操作2: 远程标签操作"></a>Git标签操作2: 远程标签操作</h3><ul>
<li>操作概述:<ul>
<li>默认情况下,标签信息是不会随着push推送到远程端的</li>
<li>远程端的标签信息推送需要额外的命令</li>
</ul>
</li>
<li>具体做法:<ol>
<li>把一个标签推送到远程<ul>
<li><code>git push origin v1.0</code><br><span align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!206351:/git_tag_remote_add.png?authkey=AJoh90nl3u6Wj4U" alt="git_tag_remote_add"></span></li>
</ul>
</li>
<li>把本地所有标签推送到远程<ul>
<li><code>git push origin --tags</code></li>
</ul>
</li>
<li>删除远程的标签<ul>
<li><code>git push origin :refs/tags/v1.0</code><br><span align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!206352:/git_tag_remote_delete.png?authkey=AJoh90nl3u6Wj4U" alt="git_tag_remote_delete"></span></li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="Git命令优化-配置别名"><a href="#Git命令优化-配置别名" class="headerlink" title="Git命令优化: 配置别名"></a>Git命令优化: 配置别名</h2><h3 id="配置别名概述"><a href="#配置别名概述" class="headerlink" title="配置别名概述:"></a>配置别名概述:</h3><ul>
<li>之前的Git命令操作都是敲的命令全名</li>
<li>其实,Git可以配置自己专有的别名,更快捷的进行操作</li>
<li>别名配置的关键词是<code>alias</code></li>
<li>别名配置的命令是:<ul>
<li><code>git config --global alias.[other name] [command]</code></li>
</ul>
</li>
<li>个人觉得别名更重要的作用是,可以配置一些自己适用的独特的log日志形式</li>
<li>配置后,仍然可以用全名的方式进行调用</li>
</ul>
<h3 id="别名配置示例"><a href="#别名配置示例" class="headerlink" title="别名配置示例:"></a>别名配置示例:</h3><ul>
<li>示例1: status –&gt; st<ul>
<li><code>git config --global alias.st status</code></li>
</ul>
</li>
<li>示例2: commit –&gt; ct<ul>
<li><code>git config --global alias.ct commit</code></li>
</ul>
</li>
<li>示例3: branch –&gt; br<ul>
<li><code>git config --global alias.br branch</code></li>
</ul>
</li>
<li>示例4: 快速撤销<ul>
<li><code>git config --global alias.unstage &#39;reset HEAD</code></li>
<li>需要退回上一版本,就用: <code>git unstage [file name]</code></li>
</ul>
</li>
<li>示例5:显示最新日志<ul>
<li><code>git conifg --global alias.last &#39;log -1</code></li>
<li>需要使用时,就用: <code>git last</code></li>
</ul>
</li>
</ul>
<h4 id="别名配置专属-log"><a href="#别名配置专属-log" class="headerlink" title="别名配置专属 log"></a>别名配置专属 log</h4><ul>
<li>可以把log配置成自己想要显示的格式,然后用一个别名进行保存</li>
<li><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></li>
<li>配置完成后,输入<code>git lg</code>,显示效果如下:<br><span align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!206354:/git_lg.png?authkey=AJoh90nl3u6Wj4U" alt="git_lg"></span></li>
</ul>
<hr>
<h2 id="常用git命令总结"><a href="#常用git命令总结" class="headerlink" title="常用git命令总结"></a><span id="git_command">常用git命令总结</span></h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ul>
<li><code>git init [project-name]</code><ul>
<li>创建本地仓库 </li>
</ul>
</li>
</ul>
<h3 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h3><ul>
<li><code>git status</code><ul>
<li>查看仓库状态,包括<ul>
<li>在哪个分支</li>
<li>仓库中文件的变化</li>
</ul>
</li>
</ul>
</li>
<li><code>git add [file]</code><ul>
<li>添加文件到就绪状态</li>
<li>就是添加文件到暂存区,使文件纳入Git管理</li>
</ul>
</li>
<li><code>git add .</code><ul>
<li>将所有改动过的文件纳入git管理</li>
</ul>
</li>
<li><code>git diff [file]</code><ul>
<li>查看文件的修改内容</li>
<li>增加的内容会用<code>+</code>,标示出来;删除的内容会用<code>-</code>标示出来</li>
</ul>
</li>
<li><code>git diff --staged</code><ul>
<li>查看暂存区中的文件(还未commit)和最新文件的不同</li>
</ul>
</li>
<li><code>git commit -m &quot;[description message]&quot;</code><ul>
<li>让文件的修改添加等命令执行,将文件变化纳入git仓库的管理</li>
<li>就是将暂存区执行的操作提交到当前分支</li>
<li>执行后就像游戏存盘了,可以方便的将文件改回某刻修改的状态 </li>
</ul>
</li>
</ul>
<h3 id="删除和重命名"><a href="#删除和重命名" class="headerlink" title="删除和重命名"></a>删除和重命名</h3><ul>
<li><code>git rm [file]</code><ul>
<li>删除本地文件和版本库中的文件</li>
<li>这样删除了的文件,还是可以使用<code>checkout</code>找回</li>
</ul>
</li>
<li><code>git rm --cached [file]</code><ul>
<li>删除版本库中的文件,但是本地仍然保留有该文件</li>
<li>可以用<code>add</code>命令存回版本库中</li>
</ul>
</li>
<li><code>git mv [file-old-name] [file-new-name]</code><ul>
<li>重命名文件</li>
<li>注意<ul>
<li>不要随便在文件本身随便重命名,git会以为是删除了旧文件新建了这个新文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul>
<li><code>git reset 撤回版本id或使用HEAD^方式</code><ul>
<li>撤回某次操作的版本</li>
<li>只是纳入到暂存区,未commit的修改,使用reset依然能撤回</li>
</ul>
</li>
<li><code>git checkout -- 文件名</code><ul>
<li>撤销未提交commit的修改</li>
<li>也可以恢复未提交commit的删除</li>
<li>注意<code>--</code>不能少,少了就变成<a href="#change_branch">切换分支</a>了</li>
</ul>
</li>
</ul>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><ul>
<li><code>git log</code><ul>
<li>显示<code>Git Bash</code>操作日志详情,包括每次提交的id号</li>
<li>有多种形式的显示方式,详情见<span id="log">下面</span></li>
</ul>
</li>
<li><code>git log --graph</code><ul>
<li>查看分支情况</li>
</ul>
</li>
<li><code>git reflog</code><ul>
<li>以<code>HEAD^</code>形式显示操作日志,不包括id号 </li>
</ul>
</li>
<li><code>git show [commit id]</code><ul>
<li>查看某次commit的超详情,包括:<ul>
<li>操作人,时间,提交信息,操作文件的详情(包括文件内容) </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="log输出的常用选项"><a href="#log输出的常用选项" class="headerlink" title="log输出的常用选项"></a><a href="#log">log输出的常用选项</a></h4><p>说明: 这些输出命名效果可以叠加的,可以在一句log命令中使用多个,生成符合自己要求的日志信息: </p>
<ol>
<li>末尾加文件名<ul>
<li>只显示某个文件名相关的日志信息</li>
</ul>
</li>
<li>-2<ul>
<li>仅显示最近两次提交,换其他数字同理</li>
</ul>
</li>
<li>-p<ul>
<li>日志中显示提交内容的差异</li>
</ul>
</li>
<li>–stat<ul>
<li>显示相关文件的统计信息(修改几次,插入几次等信息)</li>
</ul>
</li>
<li>–shortstat<ul>
<li>–stat的简单形式</li>
</ul>
</li>
<li>–name-only<ul>
<li>仅显示修改的文件信息</li>
</ul>
</li>
<li>–abbrev-commit<ul>
<li>id号(SHA-1),仅显示前几位</li>
</ul>
</li>
<li>–relative-date<ul>
<li>时间格式显示成,几小时前,几天前的样式</li>
</ul>
</li>
<li>–graph<ul>
<li>用ASCII图表形式显示.能显示分支合并的历史</li>
</ul>
</li>
<li>–pretty<ul>
<li>使用其他格式:<ul>
<li><code>--pretty=oneline</code> : 每条信息显示成一行</li>
<li><code>--pretty=short</code> : 只显示创作者和-m的信息</li>
<li><code>--pretty=full</code> : 显示创作者和提交人和-m的信息</li>
<li><code>--pretty=fuller</code> : 除了full的信息,还显示提交时间 </li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="GitHub远程操作命令"><a href="#GitHub远程操作命令" class="headerlink" title="GitHub远程操作命令"></a>GitHub远程操作命令</h4><ul>
<li><code>git clone [url]</code><ul>
<li>从Github将远程库克隆到本地</li>
<li>会将远程库中所有内容,包括里面的版本控制信息一起克隆到本地</li>
<li>clone操作完成后,本地仓库和远程仓库就具备了联系,后面可以直接通过pull和push进行同步操作;</li>
</ul>
</li>
<li><code>git fetch [remote]</code><ul>
<li>从指定的远程库中获取代码</li>
<li>这样操作,并未将远程库中的代码<code>merge</code>到本地库对应的分支上<ul>
<li>远程库通常有个<code>origin</code>标记(就是这里的<code>[remote]</code>])</li>
</ul>
</li>
<li>通常需要对比本地与远程库日志时这么操作,再进行合并</li>
</ul>
</li>
<li><code>git merge [remote]/[branch]</code><ul>
<li>将远程库和本地库上对应的分支合并</li>
</ul>
</li>
<li><code>git pull [remote] [branch]</code><ul>
<li>将远程库中信息下载并快速合并到本地对应的分支</li>
<li>相当于<code>git fetch [remote]</code>+<code>git merge [remote]/[branch]</code></li>
</ul>
</li>
<li><code>git push [remote] [branch]</code><ul>
<li>将本地的版本控制情况上传到远程,并合并到对应分支</li>
</ul>
</li>
</ul>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul>
<li><code>git branch</code><ul>
<li>查看当前项目的本地分支<ul>
<li><code>*</code>表示当前所在分支</li>
</ul>
</li>
</ul>
</li>
<li><code>git branch [branch-name]</code><ul>
<li>创建新分支</li>
</ul>
</li>
<li><span id="change_branch"><code>git checkout [branch-name]</code></span><ul>
<li>切换到<code>分支名</code>的分支</li>
<li>加<code>-b</code>参数表示创建该分支并切换到它</li>
</ul>
</li>
<li><code>git merge [branch-name]</code><ul>
<li>执行的是将<code>分支名</code>分支合并到当前分支</li>
</ul>
</li>
<li><code>git branch -d [branch-name]</code><ul>
<li>删除<code>分支名</code>分支</li>
<li>注意<ul>
<li>用完某个分支就建议删掉</li>
<li>无法删除当前所在的分支,需要切换到其他分支</li>
<li>master主分支无法删</li>
</ul>
</li>
</ul>
</li>
<li><code>git branch -D [branch-name]</code><ul>
<li>强制删除分支</li>
<li>默认情况下,分支中的内容只有被merge到其他分支后,该分支才能被顺利删除</li>
<li>使用此命令可以强制删除</li>
<li>请慎重使用此命令</li>
</ul>
</li>
</ul>
<h3 id="隐藏储存区操作"><a href="#隐藏储存区操作" class="headerlink" title="隐藏储存区操作"></a>隐藏储存区操作</h3><ul>
<li><code>git stash</code><ul>
<li>将当前所有操作放入隐藏储存区中</li>
</ul>
</li>
<li><code>git stash apply</code><ul>
<li>从隐藏储存区中取回之前存入的操作</li>
<li>并不删除隐藏储存区中的内容</li>
</ul>
</li>
<li><code>git stash drop</code><ul>
<li>删除隐藏存储区中的内容,这样就不能使用<code>apply</code>找回</li>
</ul>
</li>
<li><code>git stash pop</code><ul>
<li>从隐藏存储区中找回之前操作,并删除存储区中的内容</li>
</ul>
</li>
<li><code>git stash list</code><ul>
<li>列出隐藏存储区中的内容</li>
</ul>
</li>
</ul>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><ul>
<li><code>git tag</code><ul>
<li>查看所有标签</li>
</ul>
</li>
<li><code>git tag [tag name]</code><ul>
<li>为当前版本创建标签</li>
</ul>
</li>
<li><code>git tag [tag name] [commit id]</code><ul>
<li>给指定commit id的版本添加标签</li>
</ul>
</li>
<li><code>git tag -a [tag name] -m &quot;[message]&quot; [commit id]</code><ul>
<li>创建带message信息的标签</li>
<li>message可以用<code>git show [tag name]</code>查看</li>
</ul>
</li>
<li><code>git show [tag name]</code><ul>
<li>查看某个标签版本的详情</li>
</ul>
</li>
<li><code>git push [remote] [tage name]</code><ul>
<li>将某个本地标签推送到远程</li>
</ul>
</li>
<li><code>git push [remote] --tags</code><ul>
<li>将本地的所有标签都推送到远程</li>
</ul>
</li>
<li><code>git push [remote] :refs/tags/[tag name]</code><ul>
<li>删除远程的某个标签 </li>
</ul>
</li>
</ul>
<p>至此,完……<br><span align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199202:/Album_Cover_清风二式_西皮士.jpg?authkey=AJoh90nl3u6Wj4U" alt="Album_Cover_清风二式_西皮士"></span></p>
<!-- 参考文献 -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文是杜若学习GitHub的笔记整理,主要参考了以下书籍,博客:&lt;ol&gt;
&lt;li&gt;&lt;a href
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java基础重修_05Lambda表达式</title>
    <link href="http://duruonanni.com/Renovate-Java-Basic-05Lambda/20180117.html"/>
    <id>http://duruonanni.com/Renovate-Java-Basic-05Lambda/20180117.html</id>
    <published>2018-01-17T09:21:25.000Z</published>
    <updated>2018-01-17T11:50:20.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><p>第一次知道Lambda表达式,是看&lt;黑客与画家&gt;中,Paul极力推崇的Lisp语言具备的重要特性.<br>当时我还没学编程,只是当科普书籍在看.<br>记得Paul曾在书中预言,Java将会在未来提供函数式编程的方法.<br>在我开始学习Java时,知道Java8的新特性中提供了Lambda表达式的概念,就知道Paul的预言应验了.<br>可之前一直没有学习这项新特性.<br>最近,重读<code>&lt;Java 核心技术&gt;</code>,利用此机会重学下Lambda表达式,并将学习记录整理至此文.<br>呐~正文开始啦~🐱‍👤</p>
<h2 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h2><ul>
<li>Lambda表达式是Java8引入的一个重要新特性</li>
<li>通过Lambda表达式,可以直接传递代码块<ul>
<li>这引入了函数式编程的概念</li>
<li>之前的Java版本中,都需要给代码块封装成类再创建对象调用</li>
</ul>
</li>
<li>Lambda表达式的引用使用接口接收,称为<code>函数式接口</code></li>
<li>Lambda表达式的出现,能让代码更简洁易懂,也提升了代码的可维护性<ul>
<li>可以使用Lambda表达式,替代单一方法的匿名内部类</li>
<li>可以使用<code>方法引用</code>的表达式,让代码更简洁</li>
</ul>
</li>
<li>此外,Lambda表达式还具备延迟执行的特点<ul>
<li>就是创建时不执行,调用时才执行</li>
</ul>
</li>
<li>由于是全新的概念,所以其语法会稍有特殊,表达方式也多样灵活,使用时需要注意</li>
</ul>
<h3 id="简单Lambda表达式示例"><a href="#简单Lambda表达式示例" class="headerlink" title="简单Lambda表达式示例"></a>简单Lambda表达式示例</h3><ul>
<li>首先,看一个不使用Lambda表达式的例子</li>
<li>这个例子中,我们想要在main方法中,调用某个接口的方法实现<ul>
<li>首先,创建接口SayHello</li>
<li>其次,创建接口的实现类Student</li>
<li>再创建一个用于实现该方法的静态方法doWithSayHello<ul>
<li>实际可以省略此步骤,直接在mian中创建类的实例调用接口方法</li>
<li>但是,对应的Lambda表达式中使用了这种中间方式</li>
<li>为了方便对比,在此处也用上了</li>
</ul>
</li>
<li>最后在main方法中,创建类的实例,调用该方法student </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithoutLambda</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// 步骤四:创建类的实例,传递到静态方法中,调用接口的方法</span></div><div class="line">		Student student = <span class="keyword">new</span> Student();</div><div class="line">		doWithSayHello(student);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 步骤三: 创建静态方法调用接口中的方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithSayHello</span><span class="params">(SayHello sh)</span> </span>&#123;</div><div class="line">		sh.sayHello(<span class="string">"Killua"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 步骤一:创建接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SayHello</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 步骤二:创建接口的实现类,并在类中重写接口方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">SayHello</span> </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		System.out.println(name + <span class="string">" say Hello World"</span>);</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>现在,想想看,上面的代码,是不是显得有点步骤过多,我们只是想要实现一个接口的方法而已呀</li>
<li>现在直接看使用Lambda表达式后,这个问题如何解决</li>
<li>注意<ul>
<li>使用Lambda表达式,我们省略了创建接口实现类的步骤</li>
<li>示例中,Lambda表达式2是lambda表达式1的简写(匿名)形式</li>
</ul>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WithLambda</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="comment">// Lambda表达式1</span></div><div class="line">			<span class="comment">// 定义了一个Lambda表达式对象sayHello2</span></div><div class="line">			<span class="comment">// =后面是接口方法的实现</span></div><div class="line">			<span class="comment">// 具体语法后面会讲</span></div><div class="line">		SayHello sayHello2 = (name)-&gt;&#123;</div><div class="line">			System.<span class="keyword">out</span>.println(name + <span class="string">"say Hello"</span>);</div><div class="line">		&#125;;</div><div class="line">			<span class="comment">// 直接传递Lambda表达式对象sayHello2,到方法中</span></div><div class="line">			<span class="comment">// 省去了定义类再实现接口的工作</span></div><div class="line">		doWithSayHello(sayHello2);</div><div class="line">		</div><div class="line">		<span class="comment">// Lambda表达式2</span></div><div class="line">			<span class="comment">// Lambda表达式1的匿名简写方法</span></div><div class="line">			<span class="comment">// 注意各种括号和分号</span></div><div class="line">		doWithSayHello((name)-&gt;&#123;</div><div class="line">			System.<span class="keyword">out</span>.println(name + <span class="string">"sayHello"</span>);</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithSayHello</span>(<span class="params">SayHello sh</span>) </span>&#123;</div><div class="line">		sh.sayHello(<span class="string">"Killua"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">@FunctionalInterface</div><div class="line"><span class="keyword">interface</span> <span class="title">SayHello</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">String name</span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="lambuda表达式语法"><a href="#lambuda表达式语法" class="headerlink" title="lambuda表达式语法"></a>lambuda表达式语法</h2><ul>
<li>由以上示例可知,Lambda表达式,就是直接传递一段代码</li>
<li>可以调用方法执行该代码,也可以传入某个对象中去<ul>
<li>Lambda表达式对象用接口去接收</li>
<li>这就叫函数式接口 </li>
</ul>
</li>
</ul>
<h3 id="函数式接口的定义"><a href="#函数式接口的定义" class="headerlink" title="函数式接口的定义"></a>函数式接口的定义</h3><ul>
<li>好了,这里要引入一个新概念: 函数式接口</li>
<li>函数式接口作用:<ul>
<li>可以用于接收Lambda表达式的对象</li>
<li>方便随时调用Lambda表达式中的方法</li>
</ul>
</li>
<li>函数式接口要求:<ul>
<li>内部只有一个抽象方法</li>
</ul>
</li>
<li>注意事项:<ul>
<li>函数式接口,可以有: <a href="#anchor1">默认方法(Default methods)</a></li>
<li>函数式接口,可以有: <a href="#anchor1">静态方法`(Static methods)</a></li>
<li>函数式接口,可以有:Object类的公有方法<ul>
<li><code>toString</code></li>
<li><code>hashCode</code>…</li>
</ul>
</li>
<li>函数式接口,请使用注解标识清楚:<ul>
<li><code>@FunctionalInterface</code></li>
</ul>
</li>
</ul>
</li>
<li>函数式接口示例: </li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span>&#123;</div><div class="line">    <span class="comment">// 函数式接口</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"></span>)</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// Object类的公有方法</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span>(<span class="params"></span>)</span>;</div><div class="line">    <span class="function">String <span class="title">toString</span>(<span class="params"></span>)</span>;</div><div class="line">    <span class="function">boolean <span class="title">equals</span>(<span class="params">Object obj</span>)</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 接口中的默认方法</span></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Java8 新特性,默认方法是也"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 接口中的静态方法</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Java8 新特性,静态方法是也"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="补充知识点-接口中的默认方法和静态方法"><a href="#补充知识点-接口中的默认方法和静态方法" class="headerlink" title="补充知识点: 接口中的默认方法和静态方法"></a>补充知识点: <span id="anchor1">接口中的默认方法和静态方法</span></h3><ul>
<li><code>默认方法</code>(Default methods)和<code>静态方法</code>(Static methods)都是Java8的新特性</li>
<li>默认方法,特点:<ul>
<li>使用<code>default</code>关键字声明方法</li>
<li>具备方法体</li>
<li>只能通过其实现类调用,实现类默认拥有此方法,这意味着:<ul>
<li>实现类可以不实现这个方法,调用类时直接调用接口中的默认方法</li>
<li>如果实现类重写了这个方法,原默认方法失效(“类优先”规则)</li>
</ul>
</li>
</ul>
</li>
<li>静态方法,特点:<ul>
<li>使用<code>static</code>关键字定义方法</li>
<li>具备静态方法的接口可以不通过实现类,而直接用接口名调用</li>
<li>静态方法可以<strong>通过接口名直接调用</strong>,也可以在接口被类实现后,由类名调用</li>
<li>静态方法初衷是简化某些工具类(工具类里面多是静态方法)对接口的实现,直接使用带静态方法的接口充当工具类</li>
<li>静态方法的出现模糊了接口和类的界限,个人不太建议使用</li>
</ul>
</li>
<li><code>默认方法</code>和<code>静态方法</code>相对较简单,就不单独写例子了 </li>
</ul>
<h3 id="函数式接口的实现"><a href="#函数式接口的实现" class="headerlink" title="函数式接口的实现"></a>函数式接口的实现</h3><h4 id="Lambda表达式1的详解"><a href="#Lambda表达式1的详解" class="headerlink" title="Lambda表达式1的详解"></a>Lambda表达式1的详解</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">S<span class="function"><span class="title">ayHello</span> sayHello2 = (<span class="keyword">name</span>)-&gt;</span>&#123;</div><div class="line">    System.out.println(<span class="keyword">name</span> + <span class="string">"say Hello"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>SayHello sayHello2</code> <ul>
<li>创建一个Lambda表达式对象</li>
<li>也就是使用函数式接口的对象,接收Lambda表达式的值</li>
</ul>
</li>
<li><code>=</code><ul>
<li>将等号右边的执行结果赋值给左边</li>
</ul>
</li>
<li><code>(...)-&gt;{ ... };</code><ul>
<li>这个就是函数式接口实现的完全体</li>
</ul>
<ol>
<li><code>(...)</code> : 方法签名<ul>
<li>用于传递接口中的形式参数</li>
<li>参数不写类型,具备类型推断的功能<ul>
<li>不使用泛型,就在定义接口方法时确定类型</li>
<li>使用泛型的话,就在实现时确定类型咯</li>
</ul>
</li>
<li>没有参数,就写个空<code>()</code>,不可省略</li>
<li>有参数,可以省略<code>()</code></li>
</ul>
</li>
<li><code>-&gt;</code> : 箭头</li>
<li><code>{ ... };</code> : 方法的实现(方法体)<ul>
<li>就是要执行的函数</li>
<li>如果执行语句是一句话,可以直接写在<code>-&gt;</code>后面,不用加<code>{}</code></li>
<li>注意结尾分号不可少<code>;</code> </li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="Lambda表达式2的详解"><a href="#Lambda表达式2的详解" class="headerlink" title="Lambda表达式2的详解"></a>Lambda表达式2的详解</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doWithSayHello((<span class="name">name</span>)-&gt;&#123;</div><div class="line">    System.out.println(<span class="name">name</span> + <span class="string">"sayHello"</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<ul>
<li>这个就相当于一个匿名的Lambda表达式</li>
<li>不创建Lambda表达式对象,直接执行doWithSayHello方法的实现</li>
<li>语法类似匿名内部类</li>
<li>注意执行完成后的分号<code>;</code> </li>
</ul>
<h3 id="Lambda表达式注意事项"><a href="#Lambda表达式注意事项" class="headerlink" title="Lambda表达式注意事项:"></a>Lambda表达式注意事项:</h3><h4 id="Lambda表达式访问外部变量"><a href="#Lambda表达式访问外部变量" class="headerlink" title="Lambda表达式访问外部变量"></a>Lambda表达式访问外部变量</h4><ul>
<li>Lambda表达式方法体中,也能访问外部的变量<ul>
<li>包括其所在方法内的局部变量</li>
<li>也包括类中<code>final</code>修饰的成员变量</li>
<li>就和内部类访问外部信息一样</li>
</ul>
</li>
<li>因为可以访问外部变量,就要注意方法签名中的变量名和外部变量的重名问题了<ul>
<li>形参名字不能和外部变量名一样,编译会无法通过 </li>
</ul>
</li>
<li>变量要定义在Lambda表达式实现之前,因为代码顺序执行,放在后面调用不到 </li>
</ul>
<h4 id="Lambda表达式中使用this和super关键字"><a href="#Lambda表达式中使用this和super关键字" class="headerlink" title="Lambda表达式中使用this和super关键字"></a>Lambda表达式中使用this和super关键字</h4><ul>
<li>Lambda表达式中,使用this关键字,是指本类的引用(这个方法所在类的引用)<ul>
<li><code>super</code>关键字,就是本类的超类的引用咯</li>
</ul>
</li>
<li>注意: <ul>
<li>静态方法中无法使用<code>this</code>关键字</li>
</ul>
</li>
</ul>
<h3 id="补充知识点-effectively-final变量"><a href="#补充知识点-effectively-final变量" class="headerlink" title="补充知识点: effectively final变量"></a>补充知识点: effectively final变量</h3><ul>
<li>在Java8中,新添加了一个<code>effective final 变量</code>的概念,具体是说:<ul>
<li>定义变量时,不需要人为添加<code>final</code>变量,系统会默认识别<ul>
<li>所以,有些lambda表达式中调用的外部变量,没有定义为<code>fianl</code>的,也不报错</li>
</ul>
</li>
</ul>
</li>
<li>个人认为这个不适合新手<ul>
<li>不显示的定义出来,程序员有时候意识不到,在表达式内部对变量重新赋值,就会报错</li>
<li>反正使用时需要牢记,不能改变外部变量的值</li>
</ul>
</li>
</ul>
<h2 id="Lambda表达式和匿名内部类"><a href="#Lambda表达式和匿名内部类" class="headerlink" title="Lambda表达式和匿名内部类"></a>Lambda表达式和匿名内部类</h2><ul>
<li>除了自定义Lambda表达式外,Java8之后的很多接口也实现了函数式接口<ul>
<li>如,用于排序对比的<code>Comparator</code>接口<ul>
<li>它只有一个<code>compare</code>方法</li>
</ul>
</li>
</ul>
</li>
<li>以下示例用于对比Lambda表达式和匿名内部类 </li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class LambdaTest1 &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		List&lt;<span class="keyword">String</span>&gt; list = getList();</div><div class="line">		</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="string">"使用Lambda表达式进行排序: "</span>);</div><div class="line">		<span class="comment">// 使用Lambda表达式进行排序</span></div><div class="line">		lambdaSort(list);</div><div class="line">		<span class="comment">// 注意: 不能在main方法中直接如下使用,因为编译器无法获取方法参数的类型</span></div><div class="line">			<span class="comment">// 如果是非泛型方法,可以直接使用,不必传入方法中</span></div><div class="line">		<span class="comment">//	Collections.sort(list, (str1,str2)-&gt;str1.compareToIgnoreCase(str2););</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">str</span> : list) &#123;</div><div class="line">			System.out.<span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.<span class="built_in">println</span>();</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="string">"使用匿名内部类进行排序: "</span>);</div><div class="line">		Collections.<span class="built_in">sort</span>(list, <span class="keyword">new</span> Comparator&lt;<span class="keyword">String</span>&gt;() &#123;</div><div class="line">			@Override</div><div class="line">			<span class="keyword">public</span> <span class="built_in">int</span> compare(<span class="keyword">String</span> o1, <span class="keyword">String</span> o2) &#123;</div><div class="line">				<span class="keyword">return</span> o2.compareToIgnoreCase(o1);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">str</span> : list) &#123;</div><div class="line">			System.out.<span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">" "</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 创建一个传递方法,用于实现Lambda表达式</span></div><div class="line">	<span class="keyword">static</span> <span class="keyword">void</span> lambdaSort(List&lt;<span class="keyword">String</span>&gt; strs) &#123;</div><div class="line">		Collections.<span class="built_in">sort</span>(strs, (str1,str2)-&gt;str1.compareToIgnoreCase(str2));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// 初始化List方法</span></div><div class="line">	<span class="keyword">static</span> ArrayList&lt;<span class="keyword">String</span>&gt; getList() &#123;</div><div class="line">		<span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"when suddenly a White Rabbit with pink eyes ran close by her"</span>;</div><div class="line">		<span class="keyword">String</span>[] strArray = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</div><div class="line">		ArrayList&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">String</span> s : strArray) &#123;</div><div class="line">			list.<span class="built_in">add</span>(s);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> list;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Lambda表达式和匿名内部类对比说明"><a href="#Lambda表达式和匿名内部类对比说明" class="headerlink" title="Lambda表达式和匿名内部类对比说明"></a>Lambda表达式和匿名内部类对比说明</h3><ol>
<li>匿名内部类需要写类名和方法名,显得更复杂<ul>
<li>如果用上后面会讲的方法引用,Lambda表达式还可以更简洁</li>
</ul>
</li>
<li>Lambda表达式实现的方法如果带泛型,必须将方法的实现传递给一个中间方法<ul>
<li>示例中中间方法为: lambdaSort</li>
<li>作用是说明泛型参数的实际类型</li>
<li>方法不带泛型可以不使用中间方法</li>
</ul>
</li>
<li>匿名内部类相比Lambda表达式的优势是,可以实现多个方法</li>
</ol>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="方法引用概述"><a href="#方法引用概述" class="headerlink" title="方法引用概述"></a>方法引用概述</h3><ul>
<li>方法引用,实际上是把方法名字直接传给一个函数型接口变量<ul>
<li>就是省略了参数,因为都知道参数传在哪个地方用</li>
</ul>
</li>
<li>可以看作是Lambda表达式的简写<ul>
<li>方法引用简洁,格式优雅又方便理解</li>
<li>有一种说法是,好的Lambda表达式,方法体都只用一句话</li>
<li>所以,能使用方法引用时,请尽量使用方法引用</li>
</ul>
</li>
<li>语法:<ul>
<li><code>对象名或类名::方法名</code></li>
</ul>
</li>
<li>方法引用可以在以下三种情况使用:<ol>
<li><code>object::instanceMethod</code></li>
<li><code>Class::instanceMethod</code></li>
<li><code>Class::staticMethod</code></li>
</ol>
</li>
<li>方法引用示例1: <ul>
<li>示例取之前代码做比较 </li>
</ul>
</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static <span class="literal">void</span> lambdaSort(List&lt;String&gt; strs) &#123;</div><div class="line">    Collections.sort<span class="function"><span class="params">(strs, (str1,str2)-&gt;str1.compareToIgnoreCase(str2))</span>;</span></div><div class="line">    // 下面的是方法引用的写法</div><div class="line">    //<span class="title">Collections</span>.<span class="title">sort</span><span class="params">(strs, String::compareToIgnoreCase)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法引用示例2:<ul>
<li>lambda表达式方法: <code>x -&gt; System.out.println(x)</code></li>
<li>方法引用: <code>System.out::println</code></li>
</ul>
</li>
<li>方法引用示例3:<ul>
<li>lambda表达式方法: <code>x,y -&gt; Math.pow(x,y)</code></li>
<li>方法引用: <code>Math::pow</code></li>
</ul>
</li>
<li>注意:<ul>
<li>使用方法引用,传入的值为两个以上时</li>
<li>实现该方法时,传入值的顺序,对应方法中形参的顺序 </li>
</ul>
</li>
</ul>
<h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><h3 id="常用函数式接口概述"><a href="#常用函数式接口概述" class="headerlink" title="常用函数式接口概述:"></a>常用函数式接口概述:</h3><ul>
<li>Java8中,在<code>Java.util.function</code>中,帮我们定义了很多函数式接口;<ul>
<li>具体信息,参见<a href="https://docs.oracle.com/javase/8/docs/api/" title="Java8 API" target="_blank" rel="external">Java8 API</a></li>
</ul>
</li>
<li>以下列出几个较常用的函数式接口,并举例说明其用法 <ul>
<li>这些函数式接口,自己也可以写,但是API提供了,而且有些集成在了一些方法里面,用起来就很方便</li>
</ul>
</li>
</ul>
<h3 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer<t>接口</t></h3><h4 id="Consumer接口概述"><a href="#Consumer接口概述" class="headerlink" title="Consumer接口概述:"></a>Consumer<t>接口概述:</t></h4><ul>
<li>接口名 : Consumer<t></t></li>
<li>参数类型 : T</li>
<li>返回值类型 : void</li>
<li>抽象方法名 : accept</li>
<li>方法描述 : 处理一个T类型的值</li>
<li>其他方法 : andThen</li>
<li>补充知识点 : <ul>
<li>提供了一个对应的非泛型接口: <code>IntConsumer</code>,参数为int类型时建议使用,减少执行时的拆装箱</li>
<li>提供了处理两种类型参数的接口: <code>BiConsumer&lt;T,U&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="Consumer接口示例"><a href="#Consumer接口示例" class="headerlink" title="Consumer接口示例:"></a>Consumer<t>接口示例:</t></h4><ul>
<li><p>Java8中的iterable<t>接口,它提供了一个forEach()方法,可以接收一个Consumer<t>接口对象</t></t></p>
<ul>
<li><p>所以,我们可以在这个forEach()中,直接传入一个Lambda表达式,用一句话完成循环打印的要求</p>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!203841:/java_basic05_Lambda01.png?authkey=AJoh90nl3u6Wj4U" alt="java_basic05_Lambda01"></div></li>
</ul>
</li>
<li>下面示例对比两种传统forEach和重载后的forEach<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;<span class="keyword">String</span>&gt; strs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">strs.<span class="built_in">add</span>(<span class="string">"AAA"</span>);</div><div class="line">strs.<span class="built_in">add</span>(<span class="string">"bbb"</span>);</div><div class="line">strs.<span class="built_in">add</span>(<span class="string">"ccc"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 传统foreach循环打印写法</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">str</span> : strs) &#123;</div><div class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用继承自iterable接口的forEach方法,传递一个Consumer&lt;T&gt;函数式接口的Lambda表达式,更简单</span></div><div class="line">strs.forEach(<span class="built_in">str</span>-&gt; System.out.<span class="built_in">println</span>(<span class="built_in">str</span>));</div><div class="line"><span class="comment">// 使用方法引用写法,更简单</span></div><div class="line"><span class="comment">// strs.forEach(System.out::println);</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate<t>接口</t></h3><h4 id="Predicate接口概述"><a href="#Predicate接口概述" class="headerlink" title="Predicate接口概述:"></a>Predicate<t>接口概述:</t></h4><ul>
<li>接口名 : Predicate<t></t></li>
<li>参数类型 : T</li>
<li>返回值类型 : boolean</li>
<li>抽象方法名 : test</li>
<li>方法描述 : 处理T类型参数,返回boolean值</li>
<li>其他方法 : and,or,negate,isEquals</li>
<li>补充知识点 : <ul>
<li>提供了一个对应的非泛型接口: <code>IntPredicate</code>,参数为int类型时建议使用,减少执行时的拆装箱 </li>
<li>提供了处理两种类型参数的接口: <code>BiPredicate&lt;T,U&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="Predicate接口示例"><a href="#Predicate接口示例" class="headerlink" title="Predicate接口示例:"></a>Predicate<t>接口示例:</t></h4><ul>
<li>Predicate接口常用于为集合对象执行筛选条件<ul>
<li>这次示例,使用<code>BiPredicate&lt;T,U&gt;</code>接口</li>
<li>示例作用是,根据年龄筛选出列表中的人 </li>
</ul>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">    List&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    people.<span class="keyword">add</span>(<span class="keyword">new</span> Person(<span class="string">"Killua"</span>,<span class="number">11</span>));</div><div class="line">    people.<span class="keyword">add</span>(<span class="keyword">new</span> Person(<span class="string">"Netero"</span>,<span class="number">110</span>));</div><div class="line">    people.<span class="keyword">add</span>(<span class="keyword">new</span> Person(<span class="string">"alluka"</span>,<span class="number">10</span>));</div><div class="line">    people.<span class="keyword">add</span>(<span class="keyword">new</span> Person(<span class="string">"Zeno"</span>,<span class="number">67</span>));</div><div class="line"></div><div class="line">    usingLambda(people);</div><div class="line"></div><div class="line">    NotUsingLambda(people);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用了Lambda表达式的方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usingLambda</span>(<span class="params">List&lt;Person&gt; people</span>) </span>&#123;</div><div class="line">    BiPredicate&lt;Person, Integer&gt; judgeByAge = (p, i)-&gt;p.getAge()&gt;i;</div><div class="line"></div><div class="line">    people.forEach(person -&gt; &#123;</div><div class="line">        <span class="keyword">if</span>(judgeByAge.test(person,<span class="number">60</span>))</div><div class="line">            System.<span class="keyword">out</span>.println(person.getName() + <span class="string">": is a old man"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            System.<span class="keyword">out</span>.println(person.getName() + <span class="string">": is a young man"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 未使用lambda表达式的方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NotUsingLambda</span>(<span class="params">List&lt;Person&gt; people</span>) </span>&#123;</div><div class="line">    BiPredicate&lt;Person, Integer&gt; judgeByAge = <span class="keyword">new</span> BiPredicate&lt;Person, Integer&gt;() &#123;</div><div class="line">    @<span class="function">Override</span></div><div class="line">    <span class="keyword">public</span> boolean <span class="title">test</span>(<span class="params">Person person, Integer i</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (person.getAge()&gt;i)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Person person : people) &#123;</div><div class="line">        <span class="keyword">if</span>(judgeByAge.test(person,<span class="number">60</span>))</div><div class="line">            System.<span class="keyword">out</span>.println(person.getName() + <span class="string">": is a old man"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            System.<span class="keyword">out</span>.println(person.getName() + <span class="string">": is a young man"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function<t,r>接口</t,r></h3><h4 id="Function接口概述"><a href="#Function接口概述" class="headerlink" title="Function接口概述:"></a>Function<t,r>接口概述:</t,r></h4><ul>
<li>接口名 : Function<t,r></t,r></li>
<li>参数类型 : T</li>
<li>返回值类型 : R</li>
<li>抽象方法名 : apply</li>
<li>方法描述 : 处理T类型参数,返回R类型参数</li>
<li>其他方法 : compose,andThen,identity</li>
<li>补充知识点 : <ul>
<li>提供了一个对应的非泛型接口: <code>IntFunction</code>,参数为int类型时建议使用,减少执行时的拆装箱 </li>
<li>提供了处理两种类型参数的接口: <code>BiPredicate&lt;T,U,R&gt;</code>,表示传入参数是T,和U类型,返回值R类型 </li>
</ul>
</li>
</ul>
<h4 id="Function接口示例"><a href="#Function接口示例" class="headerlink" title="Function接口示例:"></a>Function<t,r>接口示例:</t,r></h4><ul>
<li>示例说明:<ul>
<li>示例是,传入一句话,算出里面多少个单词 </li>
</ul>
</li>
</ul>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> test = <span class="string">"This is a word-count test"</span>;</div><div class="line"><span class="keyword">Function</span>&lt;<span class="built_in">String</span>,<span class="built_in">Integer</span>&gt; wordCount =</div><div class="line">        s -&gt; s.split(<span class="string">" "</span>).length;</div><div class="line">System.<span class="keyword">out</span>.println(wordCount.apply(test));</div></pre></td></tr></table></figure>
<p>至此,完…… </p>
<blockquote>
<p><em>RIP Dolores O`Riordan</em> </p>
</blockquote>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!203843?authkey=AJoh90nl3u6Wj4U" alt="Wake Up And Smell The Coffee"></div>

<!-- 参考文献 -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;p&gt;第一次知道Lambda表达式,是看&amp;lt;黑客与画家&amp;gt;中,Paul极力推崇的Lisp语言具备的重要特性
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/tags/Java/"/>
    
      <category term="基础知识" scheme="http://duruonanni.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Lambda" scheme="http://duruonanni.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>Java基础重修_04Java中的泛型</title>
    <link href="http://duruonanni.com/Renovate-Java-Basic-04generics/20180115.html"/>
    <id>http://duruonanni.com/Renovate-Java-Basic-04generics/20180115.html</id>
    <published>2018-01-15T13:45:39.000Z</published>
    <updated>2018-01-19T04:01:12.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><p>初学泛型时,只知道它广泛应用在集合中,可以对集合中存入的数据类型进行限定.<br>对于带通配符的泛型类,泛型方法,泛型接口,也常会遇到,但并不太明白具体概念和使用.<br>正好,<code>&lt;Java 核心技术&gt;</code>使用了一章的内容来专门介绍泛型.<br>就利用此书重学下泛型,并将学习记录整理于此文.<br><del>主要是填之前,<a href="http://duruonanni.com/Renovate-Java-Basic-01keyworld-this/20180103.html" title="Renovate-Java-Basic-01keyworld-this">this&amp;super关键字</a>一文的坑</del><br>呐~正文开始啦~🐱‍👤</p>
<h3 id="泛型简介"><a href="#泛型简介" class="headerlink" title="泛型简介"></a>泛型简介</h3><ul>
<li>泛型(Genericity),是一种编程语言特性,它提供了<code>类型参数化</code>的能力</li>
<li>下面通过一段简单的代码来解释泛型的作用: </li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class ListGenericity &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception&#123;</div><div class="line">		ListWithoutGenericity();</div><div class="line">		ListWithGenericity();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> ListWithoutGenericity() &#123;</div><div class="line">		List strList = <span class="keyword">new</span> ArrayList();</div><div class="line">		strList.<span class="built_in">add</span>(<span class="string">"One"</span>);</div><div class="line">		strList.<span class="built_in">add</span>(<span class="string">"Two"</span>);</div><div class="line">		strList.<span class="built_in">add</span>(<span class="number">3</span>);</div><div class="line">		<span class="comment">// 执行以下时抛出类型转换异常</span></div><div class="line">		<span class="keyword">String</span> str2 = (<span class="keyword">String</span>) strList.<span class="built_in">get</span>(<span class="number">2</span>);</div><div class="line">		System.out.<span class="built_in">println</span>(strList);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> ListWithGenericity() <span class="keyword">throws</span> Exception&#123;</div><div class="line">		List&lt;<span class="keyword">String</span>&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		strList.<span class="built_in">add</span>(<span class="string">"One"</span>);</div><div class="line">		strList.<span class="built_in">add</span>(<span class="string">"Two"</span>);</div><div class="line">		<span class="comment">// strList.add(3); // 由于泛型的限定,无法通过编译</span></div><div class="line">		<span class="comment">// 因为Java的泛型在运行时执行类型擦除,所以可以通过反射添加不符合泛型的数据</span></div><div class="line">		strList.getClass().getMethod(<span class="string">"add"</span>, <span class="keyword">Object</span>.class).invoke(strList, <span class="number">3</span>);</div><div class="line">		System.out.<span class="built_in">println</span>(strList);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="以上代码说明"><a href="#以上代码说明" class="headerlink" title="以上代码说明:"></a>以上代码说明:</h4><ol>
<li>在Java中<code>ArrayList</code>可以存放任意引用类型数据,因为其内部元素是Objcet,在运行时再向下转型,这样的缺点是,容易造成类型不安全<ul>
<li>比如: 存入了错误的数据类型,在取用时由于类型错误导致异常</li>
</ul>
</li>
<li>泛型在此处对<code>ArrayList</code>中的数据进行了详细的限定,通过<code>List&lt;String&gt;</code>,声明存入的数据类型必须是<code>String</code>及其子类,从而避免类型不安全出现的错误<ul>
<li>这里的String类型是详细指明了的,此处不是<code>类型参数</code>用法</li>
<li><del>关于<code>类型参数</code>后面会再讲</del><ul>
<li>(坑了,后面也没有讲泛型擦除,不知道需要说什么…残念)</li>
</ul>
</li>
</ul>
</li>
<li>在Java中,泛型是一个编译时的检查过程,此处实际代码运行时仍然是Object类型,因此可以通过动态反射越过泛型实现其他类型数据的添加 </li>
</ol>
<h4 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h4><ol>
<li>减少类的创建数目,促进代码复用性</li>
<li>避免类型转换造成的运行时错误</li>
<li>泛型的出现,为创建容器类提供了方便</li>
</ol>
<h2 id="类型参数的泛型用法"><a href="#类型参数的泛型用法" class="headerlink" title="类型参数的泛型用法"></a>类型参数的泛型用法</h2><p>使用<code>类型参数</code>的泛型,就是将泛型中的具体类型,用一个虚拟参数代替.<br>在对应的泛型数据实例化时,再具体指定泛型的类型.<br>示例如下:</p>
<ul>
<li><code>ArrayList&lt;Integer&gt;</code> : 这是一个<code>参数化</code>的泛型,<code>Integer</code>称为实际类型参数</li>
<li><code>ArrayList&lt;E&gt;</code> : 这是一个带<code>类型参数</code>的泛型,其中<code>E</code>称为<code>类型参数</code> </li>
<li><code>ArrayList</code> : 是泛型类的原始类型 </li>
</ul>
<h3 id="常用类型参数标记符"><a href="#常用类型参数标记符" class="headerlink" title="常用类型参数标记符"></a>常用类型参数标记符</h3><ol>
<li>T - Type : 常用于Java类<br> 1.1 多种参数类型时常用T后面的字母表示如: U , V 等</li>
<li>E - Element : 常用于集合</li>
<li>K,V - Key,Value : 常用于Map中的键值对</li>
<li>? - 表示不确定的类型</li>
</ol>
<h3 id="简单泛型类"><a href="#简单泛型类" class="headerlink" title="简单泛型类"></a>简单泛型类</h3><p>以下是一个简单的泛型类:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;T, U&gt; &#123;</span></div><div class="line">	</div><div class="line">	<span class="keyword">private</span> T first;</div><div class="line">	<span class="keyword">private</span> U second;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, U second)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.first = first;</div><div class="line">		<span class="keyword">this</span>.second = second;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> first;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.first = first;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> U <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> second;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(U second)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.second = second;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上泛型类的”实例化”以及测试方法:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class PairTest &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		<span class="keyword">String</span>[] strs = &#123;<span class="string">"abc"</span>,<span class="string">"123"</span>,<span class="string">"qwert"</span>,<span class="string">"aaa"</span>&#125;;</div><div class="line">		Pair&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; test = minmax(strs);</div><div class="line">		System.out.<span class="built_in">println</span>(test.getFirst()+ <span class="string">"..."</span> + test.getSecond());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; minmax(<span class="keyword">String</span>[] strs) &#123;</div><div class="line">		<span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) </div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">String</span> <span class="built_in">min</span> = strs[<span class="number">0</span>];</div><div class="line">		<span class="keyword">String</span> <span class="built_in">max</span> = strs[<span class="number">0</span>];</div><div class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</div><div class="line">			<span class="built_in">min</span> = strs[i].compareTo(<span class="built_in">min</span>)&gt;<span class="number">0</span> ? <span class="built_in">min</span> : strs[i];</div><div class="line">			<span class="built_in">max</span> = strs[i].compareTo(<span class="built_in">max</span>)&lt;<span class="number">0</span> ? <span class="built_in">max</span> : strs[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;(<span class="built_in">min</span>,<span class="built_in">max</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="简单泛型类的说明"><a href="#简单泛型类的说明" class="headerlink" title="简单泛型类的说明"></a>简单泛型类的说明</h4><ol>
<li>泛型类在声明时,使用单个大写字母指代类型<ul>
<li>这里指代的类型,是给类中变量和方法使用的</li>
</ul>
</li>
<li>在创建类的实例时,需要将<code>类型参数</code>具体化<ul>
<li>eg: <code>pair&lt;Integer,String&gt;</code></li>
<li>参数类型必须是引用类型,不能使用基本数据类型</li>
</ul>
</li>
<li>向泛型对象存入基本数据类型值,会发生自动拆装箱<ul>
<li>应该尽量避免这样操作,因为自动拆装箱会消耗性能</li>
</ul>
</li>
<li>Java不支持泛型化数组</li>
<li>泛型类中无法定义静态泛型成员<ul>
<li>因为静态成员实例化时先执行,必须明确其类型</li>
</ul>
</li>
<li><span id="anchor1">泛型类型不能直接或间接的继承自<code>Throwable</code></span><ul>
<li>因为类型不确定</li>
<li>这意味着不能抛出或捕获泛型类的异常对象</li>
</ul>
</li>
<li>泛型类派生子类:<ul>
<li>子类需要指明数据类型,或者使用默认的object类型 </li>
</ul>
</li>
<li>泛型类型的继承关系:<ul>
<li>泛型类是其原始类型的子类,和泛型实例化后其内部子父类关系无关</li>
<li>可以联想<code>ArrayList&lt;Manager&gt;</code>和<code>ArrayList&lt;Employee&gt;</code>并无子父类关系</li>
</ul>
</li>
</ol>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><h4 id="泛型方法概述及说明"><a href="#泛型方法概述及说明" class="headerlink" title="泛型方法概述及说明"></a>泛型方法概述及说明</h4><ol>
<li>泛型方法是使用了<code>类型参数</code>泛型的方法<ul>
<li>泛型参数可以是方法的返回值,或者形参</li>
</ul>
</li>
<li>泛型方法可以再泛型类或者普通类中定义</li>
<li>在调用该方法时,编译器能自动通过传入实际参数或者用于接收的返回值推断<code>类型参数</code>的具体化值<ul>
<li>所以可以像普通方法那样不在调用时说明参数类型 </li>
</ul>
</li>
</ol>
<h4 id="泛型方法代码示例"><a href="#泛型方法代码示例" class="headerlink" title="泛型方法代码示例:"></a>泛型方法代码示例:</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lists</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">// 泛型方法中,使用"..."可变参数很方便</span></div><div class="line">	<span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; toList(T... arr) &#123;</div><div class="line">		<span class="keyword">List</span>&lt;T&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;T&gt;();</div><div class="line">		<span class="keyword">for</span>(T a: arr) </div><div class="line">			<span class="keyword">list</span>.add(a);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">list</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args) &#123;</div><div class="line">		<span class="comment">// 注意实例化时,并未注明泛型方法的具体类型,编译器可以"自动推断"</span></div><div class="line">		<span class="keyword">List</span>&lt;Integer&gt; ints = Lists.toList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">		<span class="keyword">List</span>&lt;String&gt; strs = Lists.toList(<span class="string">"hello"</span>,<span class="string">"genericity"</span>);</div><div class="line">		System.out.println(<span class="string">"ints:"</span> + ints.toString() + <span class="string">" ; strs:"</span> + strs.toString());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><h4 id="泛型接口概述及说明"><a href="#泛型接口概述及说明" class="headerlink" title="泛型接口概述及说明"></a>泛型接口概述及说明</h4><ol>
<li>Java中的接口也可以定义泛型</li>
<li>泛型接口的最广泛示例是<code>生成器</code><br> 2.1 使用工厂模式时,其内部通常需要提供一个方法生产对象<br> 2.2 生成器方法的返回值通常是该类的实例<br> 2.3 使用泛型接口做生成器的好处 : 被实现时才确定类型,适用性更广<pre><code>2.3.1 不使用泛型,就只用Object类型,那样实现时强转不安全 
</code></pre></li>
</ol>
<h4 id="泛型接口示例"><a href="#泛型接口示例" class="headerlink" title="泛型接口示例"></a>泛型接口示例</h4><ul>
<li>示例说明:<ul>
<li>采用两个类的对比说明泛型接口的优势</li>
<li>在示例中,顺便实现了<a href="#anchor1">泛型类型不能直接或间接的继承自<code>Throwable</code></a>的示例</li>
<li>注意观察示例中的注释,便于理解代码 </li>
</ul>
</li>
</ul>
<ol>
<li>示例容器类(Juice和Monkey) </li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Juice</span></span>&#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	public <span class="type">String</span> toString() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Juice</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Juice</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peach</span> <span class="keyword">extends</span> <span class="title">Juice</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Juice</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非果汁类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span></span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	public <span class="type">String</span> toString() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getClass().getSimpleName();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>示例1 : 带泛型接口的方法 </li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 带泛型接口</span></div><div class="line"><span class="keyword">interface</span> GenericGenerator&lt;T&gt; &#123;</div><div class="line">	T <span class="keyword">next</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> JuiceGenerator <span class="keyword">implements</span> GenericGenerator&lt;Juice&gt; &#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">Class</span>[] types = &#123;Apple.<span class="keyword">class</span>,Orange.<span class="keyword">class</span>,Peach.<span class="keyword">class</span>,Banana.<span class="keyword">class</span>&#125;;</div><div class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">	@Override</div><div class="line">	<span class="keyword">public</span> Juice <span class="keyword">next</span>() &#123; <span class="comment">// 实现方法时,必须实例化返回值类型</span></div><div class="line">	<span class="comment">// 说明: 此处为什么使用try-catch</span></div><div class="line">		<span class="comment">// 因为方法继承自泛型接口,而泛型接口不能继承Throwable接口,所以只能在方法内处理异常</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// return Monkey.class.newInstance(); // 因为Monkey不是Juice的子类,无法通过编译,避免错误</span></div><div class="line">			<span class="keyword">return</span> (Juice) types[random.nextInt(types.length)].newInstance();</div><div class="line">		&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</div><div class="line">			<span class="comment">// 说明: 在catch中 throw RuntimeException的原因</span></div><div class="line">				<span class="comment">// 因为要保证方法绝对有返回值</span></div><div class="line">				<span class="comment">// try语句中有return,但如果抛异常来到catch语句中,就必须通过抛出运行时异常使程序运行停止,来避免缺少此处的返回情况</span></div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">		JuiceGenerator gen = <span class="keyword">new</span> JuiceGenerator();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</div><div class="line">            System.out.<span class="keyword">println</span>(gen.<span class="keyword">next</span>());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>示例3: 不带泛型接口的方法 </li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不带泛型的接口,返回值使用Object</span></div><div class="line"><span class="keyword">interface</span> UnGenericGeneritor &#123;</div><div class="line">	Object <span class="keyword">next</span>() <span class="keyword">throws</span> Exception;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> JuiceGenerator2 <span class="keyword">implements</span> UnGenericGeneritor&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">Class</span>[] types = &#123;Apple.<span class="keyword">class</span>,Orange.<span class="keyword">class</span>,Peach.<span class="keyword">class</span>,Banana.<span class="keyword">class</span>&#125;;</div><div class="line">	<span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	<span class="keyword">public</span> Object <span class="keyword">next</span>() <span class="keyword">throws</span> Exception &#123; <span class="comment">// 由于接口不带泛型,所以方法可以抛异常</span></div><div class="line">		</div><div class="line">		<span class="comment">// return types[random.nextInt(types.length)].newInstance();</span></div><div class="line">		<span class="keyword">return</span> Monkey.<span class="keyword">class</span>.newInstance(); <span class="comment">// 由于返回值类型是Object,所以Monkey可以被返回,这就造成了不安全</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</div><div class="line">		JuiceGenerator2 gen = <span class="keyword">new</span> JuiceGenerator2();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</div><div class="line">            System.out.<span class="keyword">println</span>(gen.<span class="keyword">next</span>());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><h4 id="泛型约束概述及说明"><a href="#泛型约束概述及说明" class="headerlink" title="泛型约束概述及说明"></a>泛型约束概述及说明</h4><ol>
<li>使用泛型约束可以在泛型类<code>声明时</code>对泛型参数进行限制<ul>
<li>即要求满足某接口或子类等条件才能实例化</li>
<li>约束关键词是<code>extends</code></li>
</ul>
</li>
<li>约束示例: <ul>
<li><code>ClassName(T extends BoundingType)</code></li>
<li>其中T和BoundingType可以是类也可以是接口</li>
<li>T必须满足是BoundingType的子类或子接口</li>
</ul>
</li>
<li>注意: <ul>
<li>可以添加多个约束,使用<code>&amp;</code>为分隔符号;</li>
<li>多个约束条件时最多只能有一个是类,而且类必须写在约束的最前面</li>
<li>泛型约束中没有<code>super</code>关键字,要和通配符类型的泛型进行区分 </li>
</ul>
</li>
</ol>
<h4 id="泛型约束代码示例"><a href="#泛型约束代码示例" class="headerlink" title="泛型约束代码示例:"></a>泛型约束代码示例:</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericityConstriantTest</span> </span>&#123;</div><div class="line"></div><div class="line">	TestClass&lt;Integer&gt; num1 = <span class="keyword">new</span> <span class="type">TestClass</span>&lt;&gt;();</div><div class="line">	TestClass&lt;Double&gt; num2 = <span class="keyword">new</span> <span class="type">TestClass</span>&lt;&gt;();</div><div class="line">	TestClass&lt;<span class="keyword">Float</span>&gt; num3 = <span class="keyword">new</span> <span class="type">TestClass</span>&lt;&gt;();</div><div class="line">	<span class="comment">// String不是数字类型,所以下面的实例化会在编译时报错</span></div><div class="line">	TestClass&lt;<span class="keyword">String</span>&gt; str = <span class="keyword">new</span> <span class="type">TestClass</span>&lt;&gt;();</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Number 是Integer和Double的抽象超类</span></div><div class="line">	<span class="comment">// 此约束说明实例化该类时,类型必须是Number的子类,也就是数字类型</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>&lt;<span class="title">T</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Number</span></span>&gt; </span>&#123;</div><div class="line">	T num;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> T getNum() &#123;</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> void setNum(T num) &#123;</div><div class="line">		<span class="built_in">this</span>.num = num;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符 : ?"></a>类型通配符 : ?</h3><h4 id="类型通配符概述"><a href="#类型通配符概述" class="headerlink" title="类型通配符概述:"></a>类型通配符概述:</h4><p>这是泛型的最后一个难点了,也是最难的.这里来慢慢整理一下.<br>之前的学习中,我们的泛型类实例化时,都需要将参数类型具体化,这样的缺点是在参数具备子父类关系时,易受限制.<br>示例如下:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printBuddies(Pair&lt;Employee&gt; p) &#123;</div><div class="line">	Employee first = p.getFirst();</div><div class="line">	Employee <span class="built_in">second</span> = p.getSecond();</div><div class="line">	System.out.<span class="built_in">println</span>(first.getName() + <span class="string">" and "</span> + <span class="built_in">second</span>.getName() + <span class="string">" are buddies"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例中的方法是,打印两个员工的姓名.<br>因为<code>Pair&lt;Employee&gt; p</code>的限制,所以调用该方法时,就无法传递<code>Employee</code>的子类<code>Manager</code>的实例来调用此方法.<br>所以,引入了通配符类型的概念:<br><code>Pair&lt;? extends Employee&gt;</code><br>他是<code>Pair&lt;Emloyee&gt;</code>和<code>Pair&lt;Manager&gt;</code>的子类.<br>这就表示,传递的参数只要符合是<code>Employee</code>的子类,就能顺利调用方法.</p>
<h4 id="类型通配符注意事项"><a href="#类型通配符注意事项" class="headerlink" title="类型通配符注意事项:"></a>类型通配符注意事项:</h4><ol>
<li>通配符不是变量,不能在代码中使用<code>?</code>作为一种类型<ul>
<li>这意味着,不能出现下面的代码:</li>
<li><code>? a = getFirst();</code></li>
<li>由于类型不确定,也无法使用<code>set</code>方法执行赋值</li>
<li>但是,可以使用get方法判断返回值是否为<code>null</code>:</li>
<li><code>p.getFirst() = null</code></li>
</ul>
</li>
</ol>
<h4 id="类型通配符说明"><a href="#类型通配符说明" class="headerlink" title="类型通配符说明:"></a>类型通配符说明:</h4><h5 id="类型通配符分类"><a href="#类型通配符分类" class="headerlink" title="类型通配符分类:"></a>类型通配符分类:</h5><ol>
<li>子类限定<ul>
<li><code>ClassName&lt;? extends BoundingType&gt;</code></li>
<li>关键词: <code>extends</code></li>
<li>即,要求传入的实参必须是BoundingType及其子类</li>
</ul>
</li>
<li>超类限定<ul>
<li><code>ClassName&lt;? super BoundingType&gt;</code></li>
<li>关键词: <code>super</code></li>
<li>即,要求传入的实参必须是BoundingType及其子类</li>
</ul>
</li>
<li>无限定通配符<ul>
<li><code>ClassName&lt;?&gt;</code></li>
<li>对传入的实参类型不做要求</li>
<li>这个需要和参数为Object的非泛型类进行区别</li>
<li>即,无限定通配符类是所有该容器类的子类<ul>
<li>eg1: <code>Collection&lt;Object&gt;</code>和<code>Collection&lt;Integer&gt;</code>无子父类关系,不使用泛型,则无法利用多态相互转换</li>
<li>eg2: <code>Collection&lt;?&gt;</code>是 <code>Collection&lt;Object&gt;</code>和<code>Collection&lt;Integer&gt;</code>的父类,所以使用此泛型,容器类中存入任意类型都能顺利使用多态 </li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h5><ul>
<li>概念描述:<ul>
<li>之前有提到通配符类型泛型类,由于<code>?</code>不属于一种类型,所以无法对方法中的数据进行进一步操作(不知道类型就无法操作参数)</li>
<li>对于这样的情况,应该避免使用带通配符的泛型</li>
<li>如果无法避免使用,则可以通过构造一个带泛型的辅助方法来执行操作</li>
<li>具体示例见: <a href="#anchor2">PairAlg类</a> </li>
</ul>
</li>
</ul>
<h4 id="类型泛型示例解析"><a href="#类型泛型示例解析" class="headerlink" title="类型泛型示例解析"></a><java 核心技术="">类型泛型示例解析</java></h4><ul>
<li>下面是书中的类型泛型示例代码</li>
<li>我删减了代码中的一些多余部分,并添加注释</li>
<li>建议复制代码尝试运行与观察</li>
<li>具体代码如下: </li>
</ul>
<h5 id="Employee类"><a href="#Employee类" class="headerlink" title="Employee类"></a>Employee类</h5><ul>
<li>Manager类的父类</li>
<li>提供name和salary两个参数,和参数的getter,setter方法 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.salary = salary;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> salary;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.salary = salary;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Manager类"><a href="#Manager类" class="headerlink" title="Manager类"></a>Manager类</h5><ul>
<li>Manager类继承自Employee类<ul>
<li>继承了name和salary两个参数</li>
</ul>
</li>
<li>自有一个bonus参数</li>
<li>重写了getSalary()方法,目的是将salary基本工资和bonus红利相加 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> bonus;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name, salary);</div><div class="line">		bonus = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBonus</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> bonus;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.bonus = bonus;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">double</span> baseSalry = <span class="keyword">super</span>.getSalary();</div><div class="line">		<span class="keyword">return</span> baseSalry + bonus;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="泛型类Pair"><a href="#泛型类Pair" class="headerlink" title="泛型类Pair"></a>泛型类Pair<t></t></h5><ul>
<li>可以存入两个值</li>
<li>并为两个值提供了getter和setter方法 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;T&gt; &#123;</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span> T first;</div><div class="line">	<span class="keyword">private</span> T second;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.first = first;</div><div class="line">		<span class="keyword">this</span>.second = second;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> first;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.first = first;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> second;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.second = second;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="PairAlg类"><a href="#PairAlg类" class="headerlink" title="PairAlg类"></a>PairAlg类</h5><ul>
<li>用于判定Pair类中存入的两个值是否为空的工具类</li>
<li>Pair类的实现使用了通配符类型泛型</li>
<li>此处主要为了展现<span id="anchor2">通配符捕获</span>的用法 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 作用是交换Pair&lt;?&gt; 类中两个参数的值</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairAlg</span> </span>&#123;</div><div class="line">	<span class="comment">// 使用无限定通配符参数判定空值</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getSecond() == <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 调用下面的辅助方法,间接达到操作通配符泛型方法的目的</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123;</div><div class="line">		swapHelper(p);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 引入swapHelper泛型方法实现了: 通配符捕获</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span> </span>&#123;</div><div class="line">		T t = p.getFirst();</div><div class="line">		p.setFirst(p.getSecond());</div><div class="line">		p.setSecond(t);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="PairTest类"><a href="#PairTest类" class="headerlink" title="PairTest类"></a>PairTest类</h5><ul>
<li>综合介绍通配符类型泛型用法的类</li>
<li>添加了注释帮助理解代码 </li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class PairTest &#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		Manager ceo = <span class="keyword">new</span> Manager(<span class="string">"Ging"</span>, <span class="number">800000</span>);</div><div class="line">		Manager cfo = <span class="keyword">new</span> Manager(<span class="string">"Killua"</span>, <span class="number">600000</span>);</div><div class="line">		Manager cao = <span class="keyword">new</span> Manager(<span class="string">"Gon"</span>, <span class="number">500000</span>);</div><div class="line"></div><div class="line">		Pair&lt;Manager&gt; buddies = <span class="keyword">new</span> Pair&lt;&gt;(cfo, cao);</div><div class="line">		printBuddies(buddies);</div><div class="line"></div><div class="line">		ceo.setBonus(<span class="number">200000</span>);</div><div class="line">		cfo.setBonus(<span class="number">500000</span>);</div><div class="line">		cao.setBonus(<span class="number">600000</span>);</div><div class="line">		Manager[] managers = &#123; ceo, cfo, cao &#125;;</div><div class="line">		Pair&lt;Employee&gt; result = <span class="keyword">new</span> Pair&lt;&gt;();</div><div class="line">		minmaxBonus(managers, result);</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="string">"first: "</span> + result.getFirst().getName() + <span class="string">", second: "</span> + result.getSecond().getName());</div><div class="line">		maxminBonus(managers, result);</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="string">"first: "</span> + result.getFirst().getName() + <span class="string">", second: "</span> + result.getSecond().getName());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 方法作用是: 打印传入的两位经理name信息</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> printBuddies(Pair&lt;? extends Employee&gt; p) &#123; <span class="comment">// 使用通配符泛型子类限定</span></div><div class="line">		<span class="comment">// Pair&lt;? extends Employee&gt; 是 Pair&lt;Manager&gt;的父类,所以可以正确执行</span></div><div class="line">		Employee first = p.getFirst();</div><div class="line">		Employee <span class="built_in">second</span> = p.getSecond();</div><div class="line">		System.out.<span class="built_in">println</span>(first.getName() + <span class="string">" and "</span> + <span class="built_in">second</span>.getName() + <span class="string">" are buddies"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 方法作用是: 找出数组中经理红利Bonus最多和最少的人</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> minmaxBonus(Manager[] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result) &#123;</div><div class="line">		<span class="comment">// Pair&lt;? super Manager&gt; 使用通配符泛型超类限定</span></div><div class="line">		<span class="keyword">if</span> (a.length == <span class="number">0</span>)</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		Manager <span class="built_in">min</span> = a[<span class="number">0</span>];</div><div class="line">		Manager <span class="built_in">max</span> = a[<span class="number">0</span>];</div><div class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">			<span class="keyword">if</span> (<span class="built_in">min</span>.getBonus() &gt; a[i].getBonus())</div><div class="line">				<span class="built_in">min</span> = a[i];</div><div class="line">			<span class="keyword">if</span> (<span class="built_in">max</span>.getBonus() &lt; a[i].getBonus())</div><div class="line">				<span class="built_in">max</span> = a[i];</div><div class="line">		&#125;</div><div class="line">		result.setFirst(<span class="built_in">min</span>);</div><div class="line">		result.setSecond(<span class="built_in">max</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 方法作用是,对minmaxBonus方法的值进行交换</span></div><div class="line">	<span class="comment">// 调用了工具类PairAlg的方法</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> maxminBonus(Manager[] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result) &#123;</div><div class="line">		minmaxBonus(a, result);</div><div class="line">		PairAlg.swapHelper(result);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此,完……</p>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!201551?authkey=AJoh90nl3u6Wj4U" alt="Album_Cover_异国迷路のクロワーゼ" title="Album_Cover_异国迷路のクロワーゼ"></div>


<!-- 参考文献 --> 
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;p&gt;初学泛型时,只知道它广泛应用在集合中,可以对集合中存入的数据类型进行限定.&lt;br&gt;对于带通配符的泛型类,泛型
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/tags/Java/"/>
    
      <category term="基础知识" scheme="http://duruonanni.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="泛型" scheme="http://duruonanni.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础重修_03正则表达式</title>
    <link href="http://duruonanni.com/Renovate-Java-Basic-03grep/20180104.html"/>
    <id>http://duruonanni.com/Renovate-Java-Basic-03grep/20180104.html</id>
    <published>2018-01-04T14:28:42.000Z</published>
    <updated>2018-01-19T04:00:36.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><ul>
<li>本系列主要记录一些Java基础的难点,参杂一些Java8的新特性<ul>
<li>主要是杜若汇集<a href="http://product.dangdang.com/24035306.html" title="Java 核心技术 卷一" target="_blank" rel="external"><java 核心技术="" 卷一=""></java></a>中遇到的难点和问题</li>
<li>适合掌握了Java基础知识的同学进行重点和难点的复习 </li>
</ul>
</li>
</ul>
<p>呐~正文开始啦~🐱‍👤</p>
<h2 id="正则表达式概述"><a href="#正则表达式概述" class="headerlink" title="正则表达式概述:"></a>正则表达式概述:</h2><ul>
<li>正则表达式(<code>regular expressions</code>): 用于描述字符串”模式”的一种工具,可以用它来完成字符串查找,替换,匹配等功能;  <ul>
<li>利用正则表达式,可以从多个数据中,筛选出需要的数据;</li>
</ul>
</li>
<li>正则表达式在代码中常写作: <code>regex</code>  </li>
<li>正则表达式不是一种编程语言,而是一种字符串特征的”筛选匹配(match)”机制,很多编程语言中都支持正则表达式;<ul>
<li>通常在数据库中使用正则表达式</li>
</ul>
</li>
<li>练习正则表达式的网站:<ul>
<li><a href="https://www.regexpal.com/" target="_blank" rel="external">https://www.regexpal.com/</a></li>
</ul>
</li>
<li>注意事项: <ul>
<li>正则表达式<strong>严格区分大小写</strong></li>
<li>由于正则表达式实际设计起来较为复杂,涉及到检索的优化,所以,对正则表达式的最基本要求是能读懂别人正则表达式的意图.能够知道正则表达式的使用场景;</li>
</ul>
</li>
</ul>
<h2 id="正则表达式组成"><a href="#正则表达式组成" class="headerlink" title="正则表达式组成:"></a>正则表达式组成:</h2><ul>
<li>正则表达式由<code>普通字符</code>和<code>元字符</code>组成;<ul>
<li>普通字符 (original character)<ul>
<li>常用的字符</li>
</ul>
</li>
<li>元字符 (meta character)<ul>
<li>用于匹配普通字符的,具备特殊含义的字符 </li>
<li>主要用到的元字符有: <ul>
<li><code>\ . * + - ^ $ | ? : ! =</code></li>
</ul>
</li>
<li>后面会讲到如何使用这些元字符</li>
<li>由于元字符的存在,在需要匹配这些元字符元素时,就需要对元字符进行转义,后面也会讲到</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常见正则表达式匹配规则"><a href="#常见正则表达式匹配规则" class="headerlink" title="常见正则表达式匹配规则"></a>常见正则表达式匹配规则</h2><h3 id="正则中常用的匹配字符语法"><a href="#正则中常用的匹配字符语法" class="headerlink" title="正则中常用的匹配字符语法:"></a>正则中常用的匹配字符语法:</h3><ul>
<li>默认匹配方式,举例:<ul>
<li><code>abc</code> : 匹配<code>abc</code>这个字符串</li>
</ul>
</li>
<li><code>[]</code> : 匹配的是<code>[</code>,<code>]</code>中的任意一个元素<ul>
<li>eg : <code>[abc]</code> : 匹配的是<code>a</code>,<code>b</code>,<code>c</code>中的任何一个</li>
</ul>
</li>
<li><code>a-b</code> : 匹配的是<code>a</code>到<code>b</code>之间的任意一个元素(注意这个整体看作一个元素)<ul>
<li>eg1 : <code>[0-9]</code> : 匹配的是唯一一个数字</li>
<li>eg2 : <code>[a-zA-Z]</code> : 匹配的是唯一一个大写或小写字母</li>
<li>eg3 : <code>[a-zA-Z_0-9]</code> : 匹配的是一个字母或一个数字或一个下划线</li>
</ul>
</li>
<li><code>\d</code> : 匹配的是一个数字0到9,相当于[0-9]</li>
<li><code>\D</code> : 匹配的是单个非数字字符<ul>
<li>对应的大写字母对应其小写字母的相反匹配,下同,故省略</li>
</ul>
</li>
<li><code>\w</code> : 匹配的是文本类字符,包括<strong>数字字母和下划线</strong></li>
<li><code>\s</code> : 匹配任意个空白符<ul>
<li>空白符包括空格,Tab,回车(\r)和换行(\n)</li>
</ul>
</li>
<li><code>()</code> : 使用<code>(</code>和<code>)</code>可以把若干个字符当成一个整体处理,这叫分组<ul>
<li>eg: <code>(abc)+</code> : 匹配一个或多个<code>abc</code>,符合的结果有<code>abc</code>,<code>abcabc</code>…<ul>
<li><code>+</code>涉及数量词,下面会详细讲</li>
</ul>
</li>
</ul>
</li>
<li><code>.</code> : 匹配的是任意一个字符<ul>
<li>eg : <code>(a.b)</code> : 匹配符合第一个字符是<code>a</code>最后一个字符是<code>b</code>,中间字符是任意值的长度为3的字符串<ul>
<li><del>解释的好绕,就那么回事儿吧</del></li>
</ul>
</li>
</ul>
</li>
<li><code>|</code> : 选择器,从多个选项中选中一个,左边优先级更高<ul>
<li>eg1 : <code>apple|pen</code> : 匹配<code>apple</code>和<code>pen</code></li>
<li>eg2 : <code>w(ei|ie)rd</code> : 匹配<code>weird</code>和<code>wierd</code></li>
</ul>
</li>
<li><code>^</code> : 边界匹配器,表示匹配行开头<ul>
<li>eg: <code>^[0-9]+[a-z]*</code> : 表示要匹配的内容至少以一个数字开头,后面接任意个小写字母的字符还<ul>
<li>匹配输入: <code>123</code>,<code>6aa</code>;不匹配输入:<code>abc</code>,<code>a33</code>  <ul>
<li>注意: <code>^</code>放在<code>[]</code>中时,表示排除</li>
</ul>
</li>
<li>eg : <code>[^abc]</code> : 匹配的是除了这三个字符之外的任何一个字符</li>
</ul>
</li>
</ul>
</li>
<li><code>$</code> : 边界匹配器,表示匹配行结尾<ul>
<li>eg: <code>^[0-9]\-\w[a-z]$</code> : 表示以一个数字开头,后跟一个<code>-</code>连字符,再接一个任意文本字符,最后一个文本字符结尾<ul>
<li>匹配输入: <code>2-aa</code>,<code>5-2c</code>;不匹配输入: <code>a-2a</code>,<code>3-a2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="正则表达式中的数量词"><a href="#正则表达式中的数量词" class="headerlink" title="正则表达式中的数量词"></a>正则表达式中的数量词</h2><ul>
<li><code>x?</code> : 代表x出现一次或不出现;</li>
<li><code>x*</code> : 代表x出现零次或一次或多次;(<del>吐槽:不就相当于没用嘛</del>)</li>
<li><code>x+</code> : 代表x出现一次或多次;</li>
<li><code>x{n}</code> : 代表x只出现n次;</li>
<li><code>x{n,}</code> : 代表x至少出现n次;</li>
<li><code>x{n,m}</code> : 代表x出现n到m次   </li>
</ul>
<h2 id="正则中常用的转义符"><a href="#正则中常用的转义符" class="headerlink" title="正则中常用的转义符:"></a>正则中常用的转义符:</h2><ul>
<li><code>x</code> : 代表 字符<code>x</code>(未转义)</li>
<li><code>\\</code> : 代表 <code>\</code></li>
<li><code>\\.</code> : 代表 <code>.</code></li>
<li><code>\t</code> : 代表 制表符</li>
<li><code>\n</code> : 代表 换行符(光标位置在原位置下一行)</li>
<li><code>\r</code> : 代表 回车符(光标位置在下一行行首)  </li>
</ul>
<h2 id="正则表达式中的断言"><a href="#正则表达式中的断言" class="headerlink" title="正则表达式中的断言"></a>正则表达式中的断言</h2><ul>
<li>概述:<ul>
<li>正则表达式中,可以使用断言来判断筛选结果前后的值,进行进一步筛选</li>
<li>断言比较难,做了解用 </li>
</ul>
</li>
</ul>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><ul>
<li>语法: <code>?=</code></li>
<li>用法示例1: <ul>
<li><code>(?=seashore)(sea|abc)</code></li>
<li><strong>先</strong>判断筛选对象是否包含<code>seashore</code>,若包含,则<strong>从头开始</strong>匹配筛选对象中包含<code>abc</code>或者<code>sea</code>的字符串</li>
<li><code>abcseashoresea123</code>,<code>seashore</code>,<code>shoreseaabc</code>,<code>seaseaabc</code>中</li>
<li>匹配的值是: <code>abcseashoresea123</code>,<code>seashore</code></li>
</ul>
</li>
<li>用法示例2:<ul>
<li><code>sea(?=shore)</code></li>
<li><strong>先</strong>匹配sea,<strong>再看后面</strong>是否包含<code>shore</code>,若包含则匹配</li>
<li><code>seashore</code>,<code>shoresea</code>,<code>shoreseaabc</code>中</li>
<li>匹配的值是<code>seashore</code> </li>
</ul>
</li>
</ul>
<h3 id="多断言判断"><a href="#多断言判断" class="headerlink" title="多断言判断"></a>多断言判断</h3><ul>
<li>因为断言放在开头时具备<strong>回到起点</strong>的能力,所以可以利用这个能力进行多断言</li>
<li>用法示例1:<ul>
<li><code>(?=.*\d).{8,15}</code> : 示例解析请将鼠标移到<a herf="" onclick="return false" title="要求用户设定的密码长度为8到16位,且必须包含数字">此处</a></li>
</ul>
</li>
<li>用法示例2:<ul>
<li><code>(?=.*\d)(?=.*[A-Z]).{8,15}</code> : 示例解析请将鼠标移到<a herf="" onclick="return false" title="要求用户设定的密码长度为8到16位并且还要有一个大写字母出现,且必须包含数字">此处</a> </li>
</ul>
</li>
</ul>
<h3 id="否断言"><a href="#否断言" class="headerlink" title="否断言"></a>否断言</h3><ul>
<li>语法: <code>?!</code><ul>
<li>表示判定条件值为false时,满足条件</li>
</ul>
</li>
<li>语法示例:<ul>
<li><code>.*{?!(abc)}</code> : 示例解析请将鼠标移到<a herf="" onclick="return false" title="要求任意不是abc为结尾的字符串">此处</a> </li>
</ul>
</li>
</ul>
<h2 id="正则表达式解读举例"><a href="#正则表达式解读举例" class="headerlink" title="正则表达式解读举例"></a>正则表达式解读举例</h2><ul>
<li><code>[0-9]{6,12}</code> <ul>
<li>表示<code>长度6到12位的数字</code>;</li>
</ul>
</li>
<li><code>1[34578][0-9]{9}</code> <ul>
<li>表示<code>11位手机号码,第1位为1,第二位为3,4,5,7,8中的一个,后面9位为0-9之间的任意数字</code>;</li>
</ul>
</li>
<li><code>a*b</code> <ul>
<li>表示<code>在多个a或零个a后面有个b；b必须为最后一个字符</code>;  </li>
</ul>
</li>
</ul>
<h2 id="String中有关正则的常用方法"><a href="#String中有关正则的常用方法" class="headerlink" title="String中有关正则的常用方法"></a>String中有关正则的常用方法</h2><ul>
<li>public booelan match(String regex) <ul>
<li>判断字符串是否匹配给定的规则</li>
</ul>
</li>
<li>public String[] split(String regex) <ul>
<li>根据正则匹配规则,将结果拆分成字符串数组</li>
</ul>
</li>
<li>public String replaceAll(String regex,String replacement) <ul>
<li>将符合规则的字符串内容,全部替换成新字符串  </li>
</ul>
</li>
</ul>
<h2 id="Java中使用正则表达式代码示例"><a href="#Java中使用正则表达式代码示例" class="headerlink" title="Java中使用正则表达式代码示例:"></a>Java中使用正则表达式代码示例:</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">System</span>.out.println(<span class="string">"请输入6位数字: "</span>);</div><div class="line">Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">System</span>.in);</div><div class="line"><span class="keyword">String</span> userInput = sacnner.nextLine();</div><div class="line"><span class="keyword">if</span>(userInput.matchs(<span class="string">"\\d&#123;6&#125;"</span>)) &#123; <span class="comment">// 写两个 \\ 是因为在代码中需要转义</span></div><div class="line">    <span class="keyword">System</span>.out.println(<span class="string">"录入成功"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">System</span>.out.println(<span class="string">"录入失败,输入有误"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此,完……</p>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199138:/Nujabes_samurai_champloo.jpg?authkey=AJoh90nl3u6Wj4U" alt="Nujabes_samurai_champloo"></div>

<!-- 参考文献 -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本系列主要记录一些Java基础的难点,参杂一些Java8的新特性&lt;ul&gt;
&lt;li&gt;主要是杜若汇集
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/tags/Java/"/>
    
      <category term="基础知识" scheme="http://duruonanni.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>寻梦环游记 观后感</title>
    <link href="http://duruonanni.com/feelings-after-watching-movie-coco/20180104.html"/>
    <id>http://duruonanni.com/feelings-after-watching-movie-coco/20180104.html</id>
    <published>2018-01-04T08:12:35.000Z</published>
    <updated>2018-01-04T12:39:38.984Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199134:/coco02.jpg?authkey=AJoh90nl3u6Wj4U" alt="coco02"></div> 

<div class="note default"><div align="center"><b> 寻梦环游记 观后感 </b></div></div>
<p>恩，观看此剧的契机是有在微信群里听到好评，加上对皮克斯的喜欢信任，憋着不看简介剧透甚至预告片的走进了影院<br>和着自己的际遇处境多少有些感慨，趁坏记忆尚未噬去此刻情绪，杂乱记下：</p>
<ul>
<li>剧名翻译，除了让人一看便知是皮克斯出品外，毫无长处，与剧情几无关系。倒是英文翻译着实让眼镜蒙雾，<strong>coco</strong>.太奶奶的名字 </li>
</ul>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199133:/coco01.jpg?authkey=AJoh90nl3u6Wj4U" alt="coco01"></div> 

<ul>
<li>这是一个关于家庭，梦想，责任和勇气的故事</li>
<li>故事发生在墨西哥，那片魔幻的拉美大陆。讲的是亡灵节当日发生的故事。说到亡灵节，我们也有与此对应的清明节怀恋先辈。但我们似乎多是沉痛哀悼，缅怀过往，祈求祝福，因为我们知道逝者一去无复还，但过去的故事可以传递下去；他们却更多欢喜和舞蹈，因为当日要迎接那边的家人来团聚，向先辈介绍而今欣欣向荣的生活</li>
<li>故事传达的信念是，对逝者的感激与铭记会得到逝者在彼端切实的响应。只要家里还供奉着先辈的痕迹，他们就可以追循着回家。家联系着天与地，真是温暖又浪漫</li>
<li>故事中的家庭，一如全世界所有勤劳温馨的家庭。家人彼此相爱，相互扶持。太奶奶年纪大了，甚至家人名字都不清楚，但太奶奶有全家人的爱。小曾孙予她讲故事，还把她名字编进故事里；婆婆推太奶奶散步，爱怜的亲吻太奶奶</li>
<li>故事中的家庭以修鞋造鞋为生计，他们有个隐秘的禁忌，就是音乐。先辈留下来的故事说，太奶奶的爸爸因为追寻音乐抛弃了这个家庭，逼的妈妈靠补鞋苦苦持家。时间让古稀的太奶奶把一切都忘了，但太奶奶却常饱含柔情喃呢那个抛弃她的爸爸，舍不得从仅有的记忆中将那人抹去</li>
<li>故事的主角米格，天性爱音乐的小男孩，崇拜镇上供奉的传奇音乐家前辈。渴望他日能登台表演，让大家喜欢他的音乐。与家人争执无果，亡灵节当日，米格机缘知晓音乐家和自己有莫大关系，可能是自己祖爷爷，这激励了他的音乐梦。米格破窗拿到了音乐家的吉他，弹奏后引起的神秘反应将他带到了死后的世界，就此，故事展开。(写着写着感想变故事简介了，不妙，就此打住)</li>
<li>进入亡灵界的米格，很轻易的就被那些现实中未曾见过的早已作古的先辈们认出，并且就像每日相见般熟悉，这都是家中供奉的他们每年此日如约回家的结果。这让我哽噎</li>
<li>太奶奶的妈妈，这个家庭的缔造者，在亡灵界(总是打成尸魂界…)的仪貌依旧美丽，只是添了些许白发。说明去世时该也尚年轻，早早的留下了coco mama一个人呢</li>
<li>故事前期始终高高在上的音乐家让我不适，在答案揭晓前一直将其当作败笔。他因为伟大的音乐受人尊敬而身居高位荣誉无数这无可厚非，但是那么长时间却未和家人相见未和太奶奶的母亲团聚这让我接受不能。直到之后剧情反转，才惊呼绝妙(其实是很老的套路，但剧情细节引人入胜，甘愿被套路啦)</li>
<li>分析这个音乐家，这是一个反权威的故事，这样的思想和我所处时代所处地域格格不入，但正是因此才显得尤其珍贵重要。音乐家，他是真正爱音乐懂音乐的人，他初次听到米格弹唱落水后，立刻跃入水中将其救起，并带他参与各种高层聚会。也是这个家伙，将祖爷爷的音乐发扬光大，甚至用他的表演吸引米格走上音乐的道路。他知道如何作秀，如何将自己打造成人们梦幻中的完美。他因此而伟大，那么，这样的家伙值得人尊敬吗？完全不，完全不。他为了成名，不择手段甚至杀死打算还乡的搭档，将搭档愿意舍去的一切据为己有，除了那个他永远带不走的东西，家庭。从来没有功过相抵，杀人犯就是杀人犯，他给大众带去的天籁都是混着血的，这怎能原谅。故事打破了伟大的权威，在众多人的努力下还原了事实和真相。美好的事物不需要吹捧自是香甜，时间会证明这一切</li>
<li>故事的太爷爷温柔浪漫但懦弱，万幸太奶奶的坚韧被米格继承，也是幸亏米格小天使出现他才得以与家人相认相见。但太爷爷真是为音乐而生的人，他的音乐是亡灵界孤独老人最终的心愿，也是太奶奶一生的怀恋。若让我遇到此等才气娇弱的家伙并且与其成为朋友，我愿意拼上自己一切去守护这份值得世人珍惜的灵气，我是认真的(手动基路亚认真脸)</li>
<li>小主角刷鞋弹吉他被家人带走时，奶奶脱鞋打了流浪狗dandy，还说了句，别乱给流浪狗起名字，不然他们就会赖在你家不走的。恩，最后的最后，里面最威风的那个鹦鹉纹神兽，居然就是家里曾经的猫咪。一路相伴的小狗dandy，最终也化身守护灵，护送米格回到人间。这些有了名字小动物当真的成了之死追随家庭的一员，尽职守护着家的天地两界呢</li>
<li>最后，coco去世，在那个世界，满头银发的coco被永远年轻的爸爸抱起，这个等了80年的拥抱，让人觉得好温暖。死亡一点不可怕，可爱的人到哪里都会有人爱着  </li>
</ul>
<p>Date： 2017/12/03 </p>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199131:/Movie_poster_CoCo.jpg?authkey=AJoh90nl3u6Wj4U" alt="Movie_poster_CoCo"></div>

<!-- 参考文献 -->
]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://storage.live.com/items/AEE68C12565C1619!199134:/coco02.jpg?authkey=AJoh90nl3u6Wj4U&quot; alt=&quot;coco02&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://duruonanni.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="书影乐" scheme="http://duruonanni.com/categories/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E5%BD%B1%E4%B9%90/"/>
    
    
      <category term="影评" scheme="http://duruonanni.com/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="寻梦环游记" scheme="http://duruonanni.com/tags/%E5%AF%BB%E6%A2%A6%E7%8E%AF%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java基础重修_02字段初始化的处理步骤&amp;代码块小结</title>
    <link href="http://duruonanni.com/Renovate-Java-Basic-02initial-values-priority/20180104.html"/>
    <id>http://duruonanni.com/Renovate-Java-Basic-02initial-values-priority/20180104.html</id>
    <published>2018-01-04T03:57:50.000Z</published>
    <updated>2018-01-05T02:54:38.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><ul>
<li>本系列主要记录一些Java基础的难点,参杂一些Java8的新特性<ul>
<li>主要是杜若汇集<a href="http://product.dangdang.com/24035306.html" title="Java 核心技术 卷一" target="_blank" rel="external"><java 核心技术="" 卷一=""></java></a>中遇到的难点和问题</li>
<li>适合掌握了Java基础知识的同学进行重点和难点的复习 </li>
</ul>
</li>
</ul>
<p>呐~正文开始啦~🐱‍👤</p>
<h2 id="字段初始化的处理步骤"><a href="#字段初始化的处理步骤" class="headerlink" title="字段初始化的处理步骤"></a>字段初始化的处理步骤</h2><ul>
<li>一个类中,初始化字段的方法有很多种<ol>
<li>声明后即定义值</li>
<li>初始化构造代码块</li>
<li>静态代码块</li>
<li>构造方法</li>
<li>调用方法赋值,eg:(setXxx方法)</li>
</ol>
</li>
<li>这些方法的优先级如何呢</li>
<li>我们可以设计代码来观察一下: </li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 总结:</span></div><div class="line">	<span class="comment">// 下面的代码及不严谨,只是为了验证赋值顺序才这样操作的</span></div><div class="line">		<span class="comment">// 实际开发中要避免这样重复赋值的情况</span></div><div class="line">		<span class="comment">// 里面对静态变量的调用方式也不可取</span></div><div class="line">	<span class="comment">// 请结合总结,使用注释控制初始化条件,观察测试方法的结果</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InitializeBlockTest</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		InitialBlockClass test1 = <span class="keyword">new</span> InitialBlockClass();</div><div class="line">		test1.setField(<span class="string">"set方法赋值"</span>);</div><div class="line">		System.<span class="keyword">out</span>.println(test1.getField());</div><div class="line">		InitialBlockClass test2 = <span class="keyword">new</span> InitialBlockClass(<span class="string">"有参构造赋值"</span>);</div><div class="line">		System.<span class="keyword">out</span>.println(test2.getField());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">InitialBlockClass</span> &#123;</div><div class="line">	<span class="comment">// 因为调用了静态代码块,所以成员变量使用了静态的</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String field=<span class="string">"设定初始值"</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getField</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> field;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setField</span>(<span class="params">String field</span>) </span>&#123;</div><div class="line">		InitialBlockClass.field = field;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		field=<span class="string">"静态代码块"</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		field=<span class="string">"初始化构造代码块1"</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InitialBlockClass</span>(<span class="params">String field</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.field = field;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InitialBlockClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		field=<span class="string">"空参构造赋值"</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		field=<span class="string">"初始化构造代码块2"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="初始化字段的处理步骤-结论"><a href="#初始化字段的处理步骤-结论" class="headerlink" title="初始化字段的处理步骤:结论"></a>初始化字段的处理步骤:结论</h3><ul>
<li>通过以上代码,可以得出以下初始化代码的处理步骤(优先级由高到低)如下:<ol>
<li>初始化的默认值,即声明后定义的值,对应代码示例的:<ul>
<li><code>public static String field=&quot;设定初始值&quot;;</code></li>
</ul>
</li>
<li>静态代码块中的初始化方法,对应示例代码的:<ul>
<li><code>static { field=&quot;静态代码块&quot;; }</code></li>
</ul>
</li>
<li>依据类中的顺序,执行的初始化构造代码块,对应示例代码的:<ul>
<li><code>{ field=&quot;初始化构造代码块1 }&quot;;</code>,<code>{ field=&quot;初始化构造代码块2&quot;; }</code></li>
</ul>
</li>
<li>执行对应的构造器方法<ul>
<li>如果构造器方法种调用了其他构造器方法,执行内部调用的方法进行初始化</li>
</ul>
</li>
<li>调用方法赋值,对应示例代码的:<ul>
<li><code>test1.setField(&quot;set方法赋值&quot;);</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="静态代码块和构造代码块区别"><a href="#静态代码块和构造代码块区别" class="headerlink" title="静态代码块和构造代码块区别"></a>静态代码块和构造代码块区别</h2><h3 id="代码块概述"><a href="#代码块概述" class="headerlink" title="代码块概述"></a>代码块概述</h3><ul>
<li>代码块是由大括号包裹的代码段<code>{ ... }</code>;</li>
<li>其主要作用是限制代码的有效范围<ul>
<li>即,代码块内部定义的参数/方法,在代码块外部无法直接获取</li>
</ul>
</li>
<li>代码块分类:<ul>
<li>类中方法外:<ul>
<li>静态代码块</li>
<li>构造代码块</li>
</ul>
</li>
<li>方法中:<ul>
<li>普通代码块<ul>
<li>调用时,普通代码块依据代码顺序依次执行 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="静态代码块和构造代码块"><a href="#静态代码块和构造代码块" class="headerlink" title="静态代码块和构造代码块"></a>静态代码块和构造代码块</h3><ul>
<li>构造代码块<ul>
<li>类中方法外定义的,用<code>{}</code>括起来的内容,示例见上段代码</li>
</ul>
</li>
<li>静态代码块<ul>
<li>类中方法外定义,在构造代码块前面加<code>static</code>关键字</li>
</ul>
</li>
<li>区别:<ul>
<li><code>构造代码块</code>在每次创建类对象时都会被调用,执行次序优先于类中其他方法</li>
<li><code>静态代码块</code>只有类首次被创建时才执行调用,执行次序优先于构造代码块</li>
<li><code>静态代码块</code>只能直接访问类中的静态方法和静态变量 </li>
</ul>
</li>
</ul>
<p>至此,完……</p>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199126?authkey=AJoh90nl3u6Wj4U" alt="Nujabes_Luv" title="Album Cover Nujabes_Luv"></div>

<!-- 参考文献 -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本系列主要记录一些Java基础的难点,参杂一些Java8的新特性&lt;ul&gt;
&lt;li&gt;主要是杜若汇集
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/tags/Java/"/>
    
      <category term="基础知识" scheme="http://duruonanni.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java基础重修_01关键字this&amp;super</title>
    <link href="http://duruonanni.com/Renovate-Java-Basic-01keyworld-this/20180103.html"/>
    <id>http://duruonanni.com/Renovate-Java-Basic-01keyworld-this/20180103.html</id>
    <published>2018-01-03T09:45:29.000Z</published>
    <updated>2018-01-05T02:54:21.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><ul>
<li>踩着2017的尾巴,重新启用此博客</li>
<li>之前的Java笔记,原本想把Java基础的知识尽量多写一遍,这个估计要承<a href="https://zh.moegirl.org/%E5%AF%8C%E3%AD%B4%E4%B9%89%E5%8D%9A" title="富坚义博" target="_blank" rel="external">富坚义博</a>之志啦</li>
<li>这个系列主要是记录一些Java基础的难点,参杂一些Java8的新特性<ul>
<li>主要是杜若汇集<a href="http://product.dangdang.com/24035306.html" title="Java 核心技术 卷一" target="_blank" rel="external"><java 核心技术="" 卷一=""></java></a>中遇到的难点和问题</li>
<li>本系列适合掌握了Java基础知识的同学进行重点和难点的复习<br>呐~正文开始啦~🐱‍👤 </li>
</ul>
</li>
</ul>
<h2 id="this关键字的作用"><a href="#this关键字的作用" class="headerlink" title="this关键字的作用"></a>this关键字的作用</h2><ul>
<li>概述<ol>
<li><code>this</code>关键字,可以直接调用本类的成员变量和成员方法<ul>
<li><code>this.xxx</code></li>
</ul>
</li>
<li>充当当前类对象的引用<ul>
<li><code>return this</code></li>
</ul>
</li>
<li>在构造方法中,可以用来调用其他构造方法<ul>
<li><code>this(paras...)</code> </li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="作用1-调用类中的成员变量-amp-成员方法"><a href="#作用1-调用类中的成员变量-amp-成员方法" class="headerlink" title="作用1 : 调用类中的成员变量&amp;成员方法"></a>作用1 : 调用类中的成员变量&amp;成员方法</h3><ul>
<li>在创建一个<code>JavaBean</code>时,通常会为其提供get和set方法,用于防止直接访问到类中的成员变量.其中,就用到了this关键字,eg: <ul>
<li>在此示例中,主要解决了成员变量和形式参数的重名问题;</li>
<li>语法是: <code>this.成员变量名</code> 和 <code>this.方法名</code><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> &#123;</div><div class="line">	<span class="comment">// 1.本类成员变量的age</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span>(<span class="params"><span class="keyword">int</span> age</span>) </span>&#123; <span class="comment">// 2.形参中的变量age</span></div><div class="line">		<span class="comment">// 观察可知 : 方法中形参名为age,本类中也有个成员变量名为age.这里就出现了变量的同名</span></div><div class="line">		<span class="comment">// 在Java中对重名变量的处理遵循就近优先的原则("同名变量的屏蔽原则"),即方法内的优先于方法外(成员变量)的.这里就是默认全部识别为形参的age(成员变量默认被隐藏)</span></div><div class="line">		<span class="comment">// 想要在方法中调用成员变量的age,就可以使用this关键字</span></div><div class="line">		<span class="comment">// 这里的this指的是当前类,this.age就是当前类下的成员方法</span></div><div class="line">		<span class="comment">// 这个方法的意思就是 : 将形参接收到的age值(2),传递到类中成员变量位置上的age(1)之中</span></div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// this关键字调用本类方法的简单示例</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"Hello,My name is"</span> + <span class="keyword">this</span>.getName() + <span class="string">" I'm "</span> + <span class="keyword">this</span>.getAge() + <span class="string">" year old."</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="作用2-充当当前类对象的引用"><a href="#作用2-充当当前类对象的引用" class="headerlink" title="作用2 : 充当当前类对象的引用"></a>作用2 : 充当当前类对象的引用</h3><ul>
<li>这是一种特殊的用法,使用<code>this</code>指代当前对象本身<ul>
<li>诸如,允许这样使用<code>Student student = this</code></li>
<li>可以把<code>this</code>当某个方法的返回值返回<ul>
<li>注意,这个方法必须是非静态方法</li>
<li>因为需要通过new创建了对象,使用<code>this</code>才有意义</li>
</ul>
</li>
<li>这种方法只有<code>this</code>能用,<code>super</code>中没有对应的这种用法<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JavaBean类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student02</span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student02</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">	<span class="comment">// 有参构造方法传递值,进行初始化参数</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student02</span>(<span class="params">String name, <span class="keyword">int</span> age</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 方法内初始化参数,使用this进行返回</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Student02 <span class="title">getStudent02</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		name=<span class="string">"lumia"</span>;</div><div class="line">		age=<span class="number">6</span>;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line">	@<span class="function">Override</span></div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"Student02 [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 测试方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">	Student02 student1 = <span class="keyword">new</span> Student02(<span class="string">"Samsung"</span>, <span class="number">36</span>);</div><div class="line">	Student02 student2 = <span class="keyword">new</span> Student02().getStudent02();</div><div class="line">	<span class="comment">// 返回结果: 使用构造方法生成:Student02 [name=Samsung, age=36]</span></div><div class="line">	System.<span class="keyword">out</span>.println(<span class="string">"使用构造方法生成:"</span> + student1);</div><div class="line">	<span class="comment">// 返回结果: 使用this返回值生成:Student02 [name=lumia, age=6]</span></div><div class="line">	System.<span class="keyword">out</span>.println(<span class="string">"使用this返回值生成:"</span> + student2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="作用3-构造方法中的作用"><a href="#作用3-构造方法中的作用" class="headerlink" title="作用3 : 构造方法中的作用"></a>作用3 : 构造方法中的作用</h3><ul>
<li>前言: 这种用法似乎并不太常用,大概知道下就好吧</li>
<li>一个<code>JavaBean</code>可以有多个构造方法,此时,可通过<code>this</code>关键字简化构造方法的创建;</li>
<li>在多参数的构造方法中,可以直接调用参数少的构造方法获取的值,示例如下:</li>
<li>语法: <ul>
<li>创建好一个少参数构造方法后,在创建更多参数的构造方法时,在新构造方法首句使用</li>
<li><code>this(形参1,形参2)</code></li>
<li>这样,新构造方法中,<code>形参1</code>和<code>形参2</code>的值就会调用那个少构造参数的方法赋值</li>
</ul>
</li>
<li>注意事项:<ul>
<li>这种方法只有放在新构造方法的首句才有效,否则会报错;</li>
<li>系统会自动根据参数类型识别<code>this</code>指代的构造方法;</li>
<li>实际上,每个构造方法中都能这样使用<code>this</code>,无论传入参数的多少(以上少到多只是为了方便举例)<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstructorThisTest</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		Test test = <span class="keyword">new</span> Test(<span class="string">"迷麟"</span>, <span class="string">"迷麟"</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">		System.<span class="keyword">out</span>.println(test);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Test</span> &#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String name1;</div><div class="line">	<span class="keyword">private</span> String name2;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> health1;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> health2;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 无参构造方法</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params">String name2, <span class="keyword">int</span> health2</span>) </span>&#123; <span class="comment">// 简单构造方法1</span></div><div class="line">		<span class="keyword">this</span>.name2 = <span class="string">"this+"</span> + name2;</div><div class="line">		<span class="keyword">this</span>.health2 = health2 + <span class="number">100</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 复杂构造方法2</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params">String name1, String name2, <span class="keyword">int</span> health1, <span class="keyword">int</span> health2</span>) </span>&#123;</div><div class="line">		<span class="comment">// 使用this调用简单构造方法1取值,注意必须放在方法首句</span></div><div class="line">		<span class="keyword">this</span>(name2,health2);</div><div class="line">		<span class="keyword">this</span>.name1 = name1;</div><div class="line">		<span class="keyword">this</span>.health1 = health1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@<span class="function">Override</span></div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"test [name1="</span> + name1 + <span class="string">", name2="</span> + name2 + <span class="string">", health1="</span> + health1 + <span class="string">", health2="</span> + health2 + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="super关键字的作用"><a href="#super关键字的作用" class="headerlink" title="super关键字的作用"></a>super关键字的作用</h2><ul>
<li>概述:<ul>
<li>super关键字主要用于具备继承关系的类中,从子类获取父类的信息;</li>
<li>其主要用法类似于this,以下稍做介绍</li>
<li>作用1 : 同this作用1<strong>添加超链接</strong><ul>
<li>调用父类中的成员变量&amp;成员方法</li>
<li>避免类或者方法的同名屏蔽</li>
<li>语法: <code>super.xxx</code></li>
</ul>
</li>
<li>作用2 : 同this作用3<strong>添加超链接</strong><ul>
<li>在构造方法中的相互调用</li>
<li>语法: <code>super(paras...)</code></li>
</ul>
</li>
</ul>
</li>
<li>注意事项:<ul>
<li>super不具备充当类对象引用的作用(this的作用2)</li>
<li>所有的自定义类都继承自Object类,所以所有自定义类都可以使用super;</li>
<li>此外,super关键字在<code>泛型类</code>的<code>通配符</code>类型中还可以进行<code>超类的限定</code><ul>
<li>具体用法见<code>泛型篇</code> <strong>TODO</strong></li>
</ul>
</li>
</ul>
</li>
<li>用法示例:<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 总结:</span></div><div class="line">	<span class="comment">// 子类使用new创建对象时,先调用父类的构造方法,再调用子类对应的构造方法</span></div><div class="line">	<span class="comment">// 用法1:通过super.xxx调用到父类对应的方法,sayHello</span></div><div class="line">	<span class="comment">// 用法2:使用super(paras...)构造方法,调用父类的构造方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InheritSuperTest</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		Childd child0 = <span class="keyword">new</span> Childd();</div><div class="line">		System.<span class="keyword">out</span>.println(child0);</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"------------"</span>);</div><div class="line">		Childd child2 = <span class="keyword">new</span> Childd(<span class="string">"子类实例"</span>);</div><div class="line">		System.<span class="keyword">out</span>.println(child2);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Parentt</span> &#123;</div><div class="line">	<span class="keyword">private</span> String name = <span class="string">"Parent"</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Parentt</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"父类空参构造"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Parentt</span>(<span class="params">String name</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"父类有参构造"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"父类SayHello"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Childd</span> <span class="title">extends</span> <span class="title">Parentt</span> &#123;</div><div class="line">	<span class="keyword">private</span> String name = <span class="string">"child"</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Childd</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="comment">// super用法1</span></div><div class="line">		super.sayHello();</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"子类空参构造"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Childd</span>(<span class="params">String name</span>) </span>&#123;</div><div class="line">		<span class="comment">// super用法2</span></div><div class="line">		super(name);</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"子类有参构造"</span>);</div><div class="line">	&#125;</div><div class="line">	@<span class="function">Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>) &#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"子类SayHello"</span>);</div><div class="line">	&#125;</div><div class="line">	@<span class="function">Override</span></div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"Childd [name="</span> + name + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="this在继承关系下的注意事项"><a href="#this在继承关系下的注意事项" class="headerlink" title="this在继承关系下的注意事项"></a>this在继承关系下的注意事项</h2><ul>
<li><code>this</code>在继承关系(纯子类和多态类)下,调用比较诡异复杂,容易出错;</li>
<li>以下是我的总结和代码示例,请结合代码示例来看总结;<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//总结:</span></div><div class="line">	<span class="comment">// 1. 使用this(xxx)调用构造方法,在多态类和纯子类下,都只会调用到父类对应的方法(如果父类没有这样的构造方法,编译无法通过)</span></div><div class="line">	<span class="comment">// 2. 使用this.xxx调用类中成员变量,若子类重写(覆盖)了这个变量,在多态类和纯子类下,都只会调用到子类的成员变量(如果没有重写,则调用父类的)</span></div><div class="line">	<span class="comment">// 2.1 对于多态类来说,使用 对象名.成员变量 ,是调用父类的成员变量(如果父类没有这个成员变量,编译无法通过)</span></div><div class="line">	<span class="comment">// 2.2 对于纯子类来说,使用 对象名.成员变量,是调用子类的成员变量(如果子类没有,则调用父类的)</span></div><div class="line">	<span class="comment">// 3. 使用this.yyy(paras...)调用类中的成员方法,若子类重写了该方法,在多态类和纯子类下,都只会调用子类的方法(没有重写就调用父类的)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InheritThisTest</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		Parent test = <span class="keyword">new</span> Child(<span class="string">"world"</span>); <span class="comment">// 多态类实例</span></div><div class="line">		<span class="comment">// 调用方法参见,总结: 1,2,2.1</span></div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"多态类 使用this引用: "</span> + test.helloTest() + <span class="string">"; 直接引用: "</span> + test.hello);</div><div class="line">		Child test2 = <span class="keyword">new</span> Child(<span class="string">"world"</span>); <span class="comment">// 纯子类实例</span></div><div class="line">		<span class="comment">// 调用方法参见,总结: 1,2,2.2</span></div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"纯子类 使用this引用: "</span> + test2.helloTest() + <span class="string">"; 直接引用: "</span> + test2.hello);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</div><div class="line">	<span class="keyword">public</span> String hello = <span class="string">"Hello Parent "</span>;</div><div class="line">	Parent() &#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"父类空参构造方法"</span>);</div><div class="line">	&#125;</div><div class="line">	Parent(String hello) &#123;</div><div class="line">		<span class="keyword">this</span>();</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"父类有参构造方法: "</span> + <span class="keyword">this</span>.hello);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">changeNum</span>(<span class="params"><span class="keyword">int</span> num</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> num+<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">helloTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="keyword">this</span>.changeNum(<span class="number">10</span>));</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.hello;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Child</span> <span class="title">extends</span> <span class="title">Parent</span> &#123;</div><div class="line">	<span class="comment">// 可通过注释下面变量验证,成员变量未被子类覆盖时的情况</span></div><div class="line">	<span class="keyword">public</span> String hello = <span class="string">"Hello Child "</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Child</span>(<span class="params">String hello</span>) </span>&#123;</div><div class="line">		<span class="comment">// 1. 调用空参构造,观察使用父类还是子类的方法</span></div><div class="line">		<span class="keyword">this</span>();</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"子类有参构造方法: "</span> + <span class="keyword">this</span>.hello);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 可通过注释下面方法验证,成员方法未被覆盖时的情况</span></div><div class="line">	@<span class="function">Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">changeNum</span>(<span class="params"><span class="keyword">int</span> num</span>) &#123;</div><div class="line">		<span class="keyword">return</span> num<span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	@<span class="function">Override</span></div><div class="line">	<span class="keyword">public</span> String <span class="title">helloTest</span>(<span class="params"></span>) &#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="keyword">this</span>.changeNum(<span class="number">10</span>));</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.hello;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>至此,完…… </p>
<div align="center"><img src="http://storage.live.com/items/AEE68C12565C1619!199122?authkey=AJoh90nl3u6Wj4U" alt="20th boy" title="Album Cover 20th boy"></div>

<!-- 参考文献 -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;踩着2017的尾巴,重新启用此博客&lt;/li&gt;
&lt;li&gt;之前的Java笔记,原本想把Java基础的
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/tags/Java/"/>
    
      <category term="基础知识" scheme="http://duruonanni.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_05数组(Array)</title>
    <link href="http://duruonanni.com/JavaNotes_Day05/20170622.html"/>
    <id>http://duruonanni.com/JavaNotes_Day05/20170622.html</id>
    <published>2017-06-22T04:28:30.314Z</published>
    <updated>2017-06-22T04:26:20.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>呐~这套<code>Java笔记</code>是博主在学习<strong>Java基础</strong>期间所做的笔记,现整理后分享给需要的同学.对,这会是本博客的第一个系列小文哦.<br>本笔记主要涉及Java基础学习中的知识点梳理和实际操作中的一点心得分享.<br>本笔记适合想要复习Java基础知识的同学快速查漏补缺,当然,也适合Java初学者的查阅.<br>对啦: 本文以JDK1.7为基准,但后期会加上一些JDK1.8新特性的讲解.<br>因为博主的技浅才疏,本文中的知识点也不够全面.如有错误,还望指正;如有好的建议,还望不吝赐教.<br>🐱‍👤正文开始啦~  </p>
<h1 id="Day05-数组-Array"><a href="#Day05-数组-Array" class="headerlink" title="Day05 数组(Array)"></a>Day05 数组(Array)</h1><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><p>数组是一种数据结构,用来存储数量确定的同一类型值的集合.</p>
<h3 id="数组的语法"><a href="#数组的语法" class="headerlink" title="数组的语法"></a>数组的语法</h3><p>语法1:(未赋初值,赋予其默认值)<br><code>数据类型[] 数组名 = new 数据类型[元素个数或者数组长度];</code><br>语法2:(赋初值,数组长度等于初值个数)<br><code>数据类型[] 数组名 = new {元素0值,元素1值,...,元素n值};</code></p>
<h3 id="数组的调用"><a href="#数组的调用" class="headerlink" title="数组的调用"></a>数组的调用</h3><ul>
<li>数组中的每个元素都有一个<strong>索引</strong>.</li>
<li>数组中最小的索引是0,最大的索引是”数组长度-1”</li>
<li>数组中的值通过索引调用访问</li>
<li>数组是引用元素,在方法中调用时,其传入参数改变,本身值也会变的</li>
<li>数组未初始化时,系统会默认给他赋予一个初值,不同类型的数据,其初始默认值如下:<ul>
<li>整数类型:byte,short,int,long –&gt; <code>0</code>;</li>
<li>浮点数类型:float,double –&gt; ‘0.0’;</li>
<li>字符类型:char –&gt; ‘\u0000<code>即一个空字符(空格)</code>;</li>
<li>布尔类型:boolean –&gt; <code>false</code>;</li>
<li>引用数据类型:String,类,数组… –&gt; <code>null</code>表示不引用任何元素<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3>操作数组时,依次访问数组中的每个元素,叫做数组的遍历.常通过<code>for</code>循环语句执行数组的遍历;  </li>
</ul>
</li>
</ul>
<h2 id="数组中的常见问题"><a href="#数组中的常见问题" class="headerlink" title="数组中的常见问题"></a>数组中的常见问题</h2><ul>
<li>数组中处理最值问题(引入一个第三方临时变量,赋予其索引0的值,再通过遍历比对大小进行值转换,最终比较出最大的值)</li>
<li>数组中的异常<ul>
<li>数组越界异常 <code>ArrayIndexOutOfBoundsException</code><ul>
<li>数组调用时,索引超出范围</li>
</ul>
</li>
<li>空指针异常 <code>NullPointerException</code><ul>
<li>指数组变量在调用时,其值为<code>null</code>即未指向任何数据</li>
<li>常出现在引用类型的数组当中,要注意对数组中值的正确赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>定义:在数组中嵌套的数组(数组中值的类型是数组)<br>语法:  </p>
<ol>
<li>元素长度确定的数组<br><code>int[][] arr = new int[3][4];</code></li>
<li>元素长度不确定的数组<br><code>int[][] arr = new int[3][];</code></li>
<li>边定义边赋值的数组<br><code>int[][] arr = {{1,2} , {3,4,5,6} , {7,8,9}}</code>;<br>二维数组的访问语法:<br><code>arr[0][1]</code></li>
</ol>
<h2 id="数组在Java中的内存分配"><a href="#数组在Java中的内存分配" class="headerlink" title="数组在Java中的内存分配"></a>数组在Java中的内存分配</h2><ul>
<li>栈内存:       用于执行方法,每次方法调用的时候,都会在栈内存的最上面开辟一段空间,用于该方法的执行<ul>
<li>栈内存特点: 先进后出,空间较小,运行较快</li>
</ul>
</li>
<li>堆内存:<br>用于存放数据量较大的数据,例如数组,对象:只要是new关键字创建出来的数据体,都在堆内存中<ul>
<li>堆内存特点: 空间较大,运行较慢,具备垃圾回收机制  </li>
</ul>
</li>
<li>方法区: 用于存放类的字节码对象,还有一些静态变量,和常量  </li>
<li>本地方法区: 存放和系统相关的运行方法,还有其他语言相关的方法</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;呐~这套&lt;code&gt;Java笔记&lt;/code&gt;是博主在学习&lt;strong&gt;Java基础&lt;/strong&gt;期间
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_04方法(Method)</title>
    <link href="http://duruonanni.com/JavaNotes_Day04/20170622.html"/>
    <id>http://duruonanni.com/JavaNotes_Day04/20170622.html</id>
    <published>2017-06-22T04:20:40.890Z</published>
    <updated>2017-06-22T04:24:03.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>呐~这套<code>Java笔记</code>是博主在学习<strong>Java基础</strong>期间所做的笔记,现整理后分享给需要的同学.对,这会是本博客的第一个系列小文哦.<br>本笔记主要涉及Java基础学习中的知识点梳理和实际操作中的一点心得分享.<br>本笔记适合想要复习Java基础知识的同学快速查漏补缺,当然,也适合Java初学者的查阅.<br>对啦: 本文以JDK1.7为基准,但后期会加上一些JDK1.8新特性的讲解.<br>因为博主的技浅才疏,本文中的知识点也不够全面.如有错误,还望指正;如有好的建议,还望不吝赐教.<br>🐱‍👤正文开始啦~  </p>
<h1 id="Day04-方法-Method"><a href="#Day04-方法-Method" class="headerlink" title="Day04 方法(Method)"></a>Day04 方法(Method)</h1><h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p>方法是包含多种语句来完成某件事情或者实现某个功能的代码块.  </p>
<h2 id="方法的语法"><a href="#方法的语法" class="headerlink" title="方法的语法"></a>方法的语法</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">修饰符 返回值类型 方法名(参数类型 参数名<span class="number">1</span>,参数类型 参数名<span class="number">2</span>,......) &#123;</div><div class="line">	执行语句</div><div class="line">	......</div><div class="line">	return 返回值;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明: </p>
<ul>
<li>修饰符,访问权限修饰符,限定该方法的调用范围,后面会详细讲</li>
<li>返回值类型: 限定方法返回值的类型,方法的返回值只有一个,可通过其他方法实现多个返回值,后面讲</li>
<li>参数类型,参数名:没什么好说的,注意形参和实际参数的区别和联系;</li>
<li><code>return</code>关键字: 用于结束方法及返回方法指定类型的值;</li>
<li>    返回值：被return语句返回的值，该值会返回给调用者;</li>
</ul>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>定义:<br>方法名相同,其中传入的参数类别或者传出的数据类型不同.在调用时,系统通过调用时不同的参数类别或数据类型判定出需要的方法进行运算.<br>条件:<br>方法名相同,参数个数或者参数类型不同.<br>注意:<br>如果重载和返回值类型无关  </p>
<h2 id="参数传递详解"><a href="#参数传递详解" class="headerlink" title="参数传递详解"></a>参数传递详解</h2><p>定义:  </p>
<ul>
<li>调用方法时,将指定的数值,传递给方法中的参数,叫做参数传递;</li>
<li><strong>定义方法</strong>时,参数列表中的变量,称为:<strong>形式参数</strong></li>
<li><strong>调用方法</strong>时,传入给方法的数值,称为:<strong>实际参数</strong></li>
</ul>
<h2 id="方法使用中的注意事项"><a href="#方法使用中的注意事项" class="headerlink" title="方法使用中的注意事项"></a>方法使用中的注意事项</h2><ul>
<li>方法只有被调用才会执行,不调用不执行</li>
<li>方法和方法是平级关系,不能嵌套定义<ul>
<li>一个方法中不能定义另一个方法</li>
</ul>
</li>
<li>只要访问权限允许,方法中就能调用其它方法,也能调用自己本身的方法<ul>
<li>自己调用自己叫做<strong>递归</strong></li>
</ul>
</li>
<li>定义方法时,参数列表中的形式参数之间用<code>,</code>逗号隔开</li>
<li>方法在声明时,形式参数需要写数据类型,为了开辟特定的内存空间</li>
<li>方法在调用时,实参不用写数据类型</li>
<li>如果方法声明时有返回值,在声明的代码中一定要正确返回该类型的值<ul>
<li>如果方法声明是<code>void</code>,可以不用<code>return</code>;<br>方法调用的注意事项:  </li>
</ul>
</li>
<li>调用方法时,若传入的值为基本数据类型,形式参数中值的改变不会影响到实际参数;</li>
<li>调用方法时,若传入的值为引用数据类型(如:数组),形式参数中值的改变会影响到实际参数的值;</li>
<li><strong>String</strong>参数具有特殊的<code>只读性</code>,故在传入后,其形参变化不会影响实参的值;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;呐~这套&lt;code&gt;Java笔记&lt;/code&gt;是博主在学习&lt;strong&gt;Java基础&lt;/strong&gt;期间
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_03Scanner接收键盘录入&amp;程序结构</title>
    <link href="http://duruonanni.com/JavaNotes_Day03/20170622.html"/>
    <id>http://duruonanni.com/JavaNotes_Day03/20170622.html</id>
    <published>2017-06-22T04:13:22.157Z</published>
    <updated>2017-06-22T04:17:09.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>呐~这套<code>Java笔记</code>是博主在学习<strong>Java基础</strong>期间所做的笔记,现整理后分享给需要的同学.对,这会是本博客的第一个系列小文哦.<br>本笔记主要涉及Java基础学习中的知识点梳理和实际操作中的一点心得分享.<br>本笔记适合想要复习Java基础知识的同学快速查漏补缺,当然,也适合Java初学者的查阅.<br>对啦: 本文以JDK1.7为基准,但后期会加上一些JDK1.8新特性的讲解.<br>因为博主的技浅才疏,本文中的知识点也不够全面.如有错误,还望指正;如有好的建议,还望不吝赐教.<br>🐱‍👤正文开始啦~  </p>
<h1 id="Day03-Scanner接收键盘录入-amp-程序结构"><a href="#Day03-Scanner接收键盘录入-amp-程序结构" class="headerlink" title="Day03 Scanner接收键盘录入&amp;程序结构"></a>Day03 Scanner接收键盘录入&amp;程序结构</h1><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p>Scanner类的作用: 接收键盘录入</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h3><ol>
<li>导包<br> 在主类声明之外,写导包语句(通常写在代码最开头):<br> <code>import java.util.Scanner;</code>  </li>
<li>创建键盘录入对象<br><code>Scanner s = new Scanner(System.in);</code><br>注意: 引用类型变量的定义格式:<br><code>数据类型 变量名 = new 数据类型();</code></li>
<li>使用<code>Scanner</code>对象<code>sc</code>的<code>nextInt()</code>方法,获取键盘录入的数字<br> <code>int x = s.nextInt();</code>  </li>
<li>使用<code>Scanner</code>对象<code>sc</code>的<code>next()</code>方法,获取键盘录入的值<br> <code>String str = s.next();</code></li>
</ol>
<h2 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h2><h3 id="程序的机构分类"><a href="#程序的机构分类" class="headerlink" title="程序的机构分类:"></a>程序的机构分类:</h3><ol>
<li>顺序结构</li>
<li>分支结构</li>
<li>循环结构</li>
</ol>
<h3 id="分支结构介绍"><a href="#分支结构介绍" class="headerlink" title="分支结构介绍:"></a>分支结构介绍:</h3><ul>
<li><code>if-else-if</code>语句  </li>
<li><code>switch-case</code>语句  <ul>
<li>注意: <code>break</code>不能省略;将<code>default</code>放到最后  </li>
</ul>
</li>
</ul>
<h3 id="循环结构介绍"><a href="#循环结构介绍" class="headerlink" title="循环结构介绍"></a>循环结构介绍</h3><p>Java中使用的循环种类:</p>
<ul>
<li><code>for</code>循环</li>
<li><code>while</code>循环</li>
<li><code>do-while;</code>循环</li>
</ul>
<h4 id="控制循环的语句"><a href="#控制循环的语句" class="headerlink" title="控制循环的语句"></a>控制循环的语句</h4><ul>
<li><code>continue</code>:立即结束本次循环,重新从头开始下一次循环;</li>
<li><code>break</code>: 立即结束当前循环,跳出循环进入下面的代码;</li>
<li><code>return</code>: 结束当前方法(相当于break只能跳出一个循环,如果循环外是另一个循环,则执行外部循环的内容;而return是结束所有的循环,跳出循环外);</li>
<li><code>System.exit()</code>:直接结束虚拟机,结束所有程序</li>
</ul>
<h4 id="循环结构的注意事项"><a href="#循环结构的注意事项" class="headerlink" title="循环结构的注意事项:"></a>循环结构的注意事项:</h4><ul>
<li>循环和循环之间可以嵌套;</li>
<li>循环语句中新建的变量不能被外部调用到,所以尽量将需要调用的变量声明在循环之外;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;呐~这套&lt;code&gt;Java笔记&lt;/code&gt;是博主在学习&lt;strong&gt;Java基础&lt;/strong&gt;期间
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_02数据类型&amp;运算符</title>
    <link href="http://duruonanni.com/JavaNotes_Day02/20170622.html"/>
    <id>http://duruonanni.com/JavaNotes_Day02/20170622.html</id>
    <published>2017-06-22T03:55:59.269Z</published>
    <updated>2017-06-22T03:59:59.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>呐~这套<code>Java笔记</code>是博主在学习<strong>Java基础</strong>期间所做的笔记,现整理后分享给需要的同学.对,这会是本博客的第一个系列小文哦.<br>本笔记主要涉及Java基础学习中的知识点梳理和实际操作中的一点心得分享.<br>本笔记适合想要复习Java基础知识的同学快速查漏补缺,当然,也适合Java初学者的查阅.<br>对啦: 本文以JDK1.7为基准,但后期会加上一些JDK1.8新特性的讲解.<br>因为博主的技浅才疏,本文中的知识点也不够全面.如有错误,还望指正;如有好的建议,还望不吝赐教.<br>🐱‍👤正文开始啦~  </p>
<h1 id="Day02-数据类型-amp-运算符"><a href="#Day02-数据类型-amp-运算符" class="headerlink" title="Day02 数据类型&amp;运算符"></a>Day02 数据类型&amp;运算符</h1><h2 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h2><ul>
<li><p>基本数据类型: 字节类型,整数类型,小数,字符类型,布尔类型</p>
</li>
<li><p>引用数据类型: 将基本数据类型进行包装,组合,形成比较复杂的数据,用于描述更复杂的对象,将这些为这些复杂的数据体提供一个地址,通过该地址引用那些更复杂的数据.所以也叫:<strong>地址数据类型</strong></p>
</li>
</ul>
<h2 id="进制介绍"><a href="#进制介绍" class="headerlink" title="进制介绍"></a>进制介绍</h2><ul>
<li><p>二进制(<code>binary</code>):逢二进一:数据前加<code>0b</code>;</p>
<ul>
<li>计算机中所有的数据本质都是用二进制类进行存储和计算的</li>
</ul>
</li>
<li><p>八进制(<code>octonary</code>[可联想<code>october</code>–&gt;8月]):逢八进一:数据前加<code>0</code>;</p>
</li>
<li><p>十六进制(<code>hexadecimal</code>):逢十六进一:数据前加<code>0x</code>;</p>
</li>
<li><p>十进制(<code>decimal</code>):是默认的</p>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>概述: 在程序运行过程中,值可以发生变化的量;</p>
</li>
<li><p>为便于理解,可认为: 变量是内存中装载数据的小盒子,可用来存或者取用特定的数据;</p>
</li>
<li><p>格式: 数据类型 变量名 = 变量值; eg: <code>byte b = 10;</code></p>
<ul>
<li>注意: 这里的<code>=</code>不是等号,而是赋值符号,意味着将10这个值赋予b这个byte类型的变量  </li>
</ul>
</li>
</ul>
<h3 id="位-bit-和字节-byte-介绍"><a href="#位-bit-和字节-byte-介绍" class="headerlink" title="位(bit)和字节(byte)介绍"></a>位(bit)和字节(byte)介绍</h3><ul>
<li>位(bit): 是计算机中<strong>存储数据的最小类型</strong>,常用<code>b</code>表示,位的值为<code>0</code>或者<code>1</code>;</li>
<li>字节(byte): 是计算机中的<strong>最小存储单元</strong>,常用<code>B</code>表示,一个字节(byte)由连续的8个位(bit)组成;</li>
</ul>
<h3 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型:"></a>变量的类型:</h3><ul>
<li>基本数据类型(<strong>四类八种</strong>):<ol>
<li>整数类型:<ul>
<li>byte 字节型 一个字节表示 -128~127</li>
<li>short 短整形 两个字节表示</li>
<li>int 整形(整数默认类型) 四个字节表示</li>
<li>long 长整形 八个字节表示,声明该类型要在值后面加<code>L</code></li>
</ul>
</li>
<li>小数类型:<ul>
<li>float 单精度浮点型 四个字节表示<ul>
<li>声明浮点类型要在变量值后面加<code>F</code>否则报错,因为小数类型的默认值是<code>double</code></li>
</ul>
</li>
<li>double 双精度浮点型(默认) 八个字节表示</li>
</ul>
</li>
<li>布尔类型<ul>
<li>boolean 表示T和F的类型 使用一个字节表示</li>
</ul>
</li>
<li>字节类型<ul>
<li>char 表示一个单字符 使用两个字节表示<ul>
<li>char类型值的编码与解码:  字符类型其实不能直接存储到计算机内存中，而是需要先将字符，根据编码表，转换成数字，进行存储，将来读取的时候，先将数字读取出来，然后查询编码表，看下这个数字对应的字符是什么，翻译回来<br>这个编码表，英文部分，统统用的都是<code>ASCII</code>码表<br><strong>ASCII码表其实就是字符和数字的一个对应关系</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="定义变量时的注意事项"><a href="#定义变量时的注意事项" class="headerlink" title="定义变量时的注意事项"></a>定义变量时的注意事项</h3><ul>
<li>作用域:(变量能正确使用的有效位置)<ol>
<li>变量在哪个大括号中定义,就可以在哪个大括号中使用</li>
<li>在同一个变量的作用域内,不能重复定义相同名称的变量(同名不同类型也不行)</li>
</ol>
</li>
<li>初始化:(对变量赋初值)<ul>
<li>在方法中定义的变量,或者局部变量,必须先声明(说明变量类型),再赋值(给变量初值),才能正确使用;</li>
<li>变量定义后可以不赋值,但是使用时必须赋值;</li>
</ul>
</li>
</ul>
<h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><ul>
<li>隐式转换:系统直接给转<ul>
<li>遵循小转大:字节数少的转字节数多的,直接转,类型自动变为字节数多的那种</li>
<li><code>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</code></li>
<li>注意: 在程序运行中如果因为计算或赋值超范围,系统是不会对原变量类型自动转换的,而是直接报错</li>
</ul>
</li>
<li>强制转换<ul>
<li>格式: (要转换的类型)(被转换的变量)</li>
<li>注意: 某些时候使用强转,会因为二进制的原因,造成转换后的值和原值不同</li>
</ul>
</li>
</ul>
<h3 id="Java的常量优化机制"><a href="#Java的常量优化机制" class="headerlink" title="Java的常量优化机制"></a>Java的常量优化机制</h3><ul>
<li>在Java程序编译阶段,会将简单的常量运算结果进行计算后再运行.这样的好处是:<ol>
<li>程序运行更高效</li>
<li>在String类型变量存入数据时,若常量优化(相加运算)后几个变量值相同,会默认将几个变量的值指向内存中同一个位置,使程序运行时占用内存更少,效率更高</li>
</ol>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>常见算术运算符:</p>
<ul>
<li><code>+</code> 正号;加号;字符串链接符号(可将任意类型变量值添加到字符串中)</li>
<li><code>-</code> 负号:eg: <code>int a = 3; -a;</code> 输出a的值为-3;减号</li>
<li><code>*</code> 乘号</li>
<li><code>/</code> 除号 注意:整数类型相除,省略小数点后的值</li>
<li><code>%</code> 取余符号</li>
<li><code>++</code> 自增符号:原值+1</li>
<li><code>--</code> 自减符号<ul>
<li>注意<code>++</code>和<code>--</code>与变量名位置不同的不同效果</li>
<li>在变量名前<code>++x</code>:先自加再运算</li>
<li>在变量名后<code>x--</code>:先自减再运算</li>
</ul>
</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>常见的赋值运算符</p>
<ul>
<li><code>=</code> 赋值</li>
<li><code>+=</code> 原值加上等号后的值再赋值<ul>
<li>eg: <code>int a = 2; a += 3;</code> 结果: <code>5</code></li>
</ul>
</li>
<li><code>-=</code> 原值减去等号后的值再赋值</li>
<li><code>*=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
</ul>
<h3 id="比较运算符-关系运算符"><a href="#比较运算符-关系运算符" class="headerlink" title="比较运算符(关系运算符)"></a>比较运算符(关系运算符)</h3><p>比较运算符的比较的结果是boolean类型</p>
<ul>
<li><code>==</code> 等于</li>
<li><code>!=</code> 不等于</li>
<li><code>&lt;</code> 小于</li>
<li><code>&lt;=</code> 小于或者等于</li>
<li><code>&gt;</code> 大于</li>
<li><p><code>&gt;=</code> 大于或者等于<br>思考: </p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a = <span class="number">3</span><span class="comment">;</span></div><div class="line">int <span class="keyword">b </span>= <span class="number">4</span><span class="comment">;</span></div><div class="line">System.out.println( a=<span class="keyword">b </span>)<span class="comment">;</span></div><div class="line">System.out.println( a==<span class="keyword">b </span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>  上面代码输出的结果第一个值为4，第二个值为false。为什么?</p>
</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符的运算结果是boolean类型</p>
<ul>
<li><code>&amp;</code> 与:都T为T</li>
<li><code>&amp;&amp;</code> 短路与</li>
<li><code>|</code> 或:有T则T</li>
<li><code>||</code> 短路或</li>
<li><code>^</code> 异或(就是只能有一个T,双F或者双T都返回F)</li>
<li><code>!</code> 非(eg:<code>!true</code>值是<code>false</code>)</li>
<li><code>短路</code>和<code>非短路</code>的区别: <ul>
<li><code>短路与</code>只要等式左边<code>F</code>就不判断右边的,直接值为<code>F</code>;</li>
<li><code>短路或</code>只要等式左边为<code>T</code>就不判断右边的额,直接值为<code>T</code></li>
<li>相对来说,<code>短路</code>的逻辑运算符效率更高,平时多用<code>短路</code></li>
</ul>
</li>
</ul>
<h3 id="位运算符-了解"><a href="#位运算符-了解" class="headerlink" title="位运算符(了解)"></a>位运算符(了解)</h3><p>运算二进制的运算符,其符号和逻辑运算符相同,视操作内容不同而区分</p>
<ul>
<li><code>&amp;</code> 二进制与,全1则1,否则为0<ul>
<li>eg: 10&amp;15 : 0000 1010 &amp; 0000 1111 结果 0000 1010     <code>10</code></li>
</ul>
</li>
<li><code>|</code> 二进制或,全0则0,否则为1</li>
<li><code>^</code> 二进制异或,相同为0,不同为1;</li>
<li><code>~</code> 二进制非,遇0则1,遇1则0</li>
</ul>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式:<br>    <code>(条件表达式)？表达式1：表达式2；</code><br>理解:<br>    对<code>条件表达式</code>进行判定,值为T,运行<code>表达式1</code>;值为F,运行<code>表达式2</code></p>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;呐~这套&lt;code&gt;Java笔记&lt;/code&gt;是博主在学习&lt;strong&gt;Java基础&lt;/strong&gt;期间
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_01Java基础介绍</title>
    <link href="http://duruonanni.com/JavaNotes_Day01/20170622.html"/>
    <id>http://duruonanni.com/JavaNotes_Day01/20170622.html</id>
    <published>2017-06-22T03:33:55.409Z</published>
    <updated>2017-06-22T03:46:46.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>呐~这套<code>Java笔记</code>是博主在学习<strong>Java基础</strong>期间所做的笔记,现整理后分享给需要的同学.对,这会是本博客的第一个系列小文哦.<br>本笔记主要涉及Java基础学习中的知识点梳理和实际操作中的一点心得分享.<br>本笔记适合想要复习Java基础知识的同学快速查漏补缺,当然,也适合Java初学者的查阅.<br>对啦: 本文以JDK1.7为基准,但后期会加上一些JDK1.8新特性的讲解.<br>因为博主的技浅才疏,本文中的知识点也不够全面.如有错误,还望指正;如有好的建议,还望不吝赐教.<br>🐱‍👤正文开始啦~  </p>
<h1 id="Day01随堂笔记"><a href="#Day01随堂笔记" class="headerlink" title="Day01随堂笔记"></a>Day01随堂笔记</h1><h2 id="JDK-JRE-JVM介绍"><a href="#JDK-JRE-JVM介绍" class="headerlink" title="JDK,JRE,JVM介绍"></a>JDK,JRE,JVM介绍</h2><ul>
<li>JDK:<code>JavaSE Development Kit</code> – <code>Java开发工具包</code></li>
<li>JRE:<code>Java Runtime Environment</code> – <code>Java运行时环境</code></li>
<li>JVM: <code>java Virtual Machine</code> – <code>Java虚拟机</code></li>
<li>一切Java文件都运行在JVM虚拟机中,来达到全平台运行</li>
<li>JRE = JVM + 核心类库</li>
<li>JDK = JRE + 开发工具</li>
<li>电脑上有JRE可以运行Java程序,但是不能进行开发</li>
<li>电脑上有JDK才能开发Java程序</li>
<li>目前JDK的最新版本时JDK8</li>
</ul>
<h2 id="写一个HelloWorld"><a href="#写一个HelloWorld" class="headerlink" title="写一个HelloWorld"></a>写一个<code>HelloWorld</code></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"HelloWorld"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Java书写时的注意事项"><a href="#Java书写时的注意事项" class="headerlink" title="Java书写时的注意事项:"></a>Java书写时的注意事项:</h2><ul>
<li>Java程序的后缀名为<code>.java</code></li>
<li>Java程序中区分大小写</li>
<li>括号匹配: 所有的括号都成对出现,为了防止程序少括号,建议先写前后括号,再写括号中的内容</li>
<li>标点符号: Java代码中要求所有的标点符号都是英文状态的,为了避免输入错误,建议在输入法中调整成在中文状态下,使用英文标点.</li>
<li>分号:每个句子以分号结束.注意句子结束一定要加分号.  </li>
</ul>
<h2 id="Java代码书写格式"><a href="#Java代码书写格式" class="headerlink" title="Java代码书写格式"></a>Java代码书写格式</h2><ul>
<li>括号对齐<ul>
<li>右括号换行,对齐本层代码中的第一个字母;</li>
<li>左括号和第一行代码同行,在写之前加一个空格;</li>
<li>写左括号的第一行代码要缩进,该行代码里面的内容要缩进;</li>
<li>所有运算符的两边都添加空格.eg <code>1 + 1 + 3 + 3</code>;</li>
</ul>
</li>
</ul>
<h2 id="注释-关键字-标识符"><a href="#注释-关键字-标识符" class="headerlink" title="注释,关键字,标识符"></a>注释,关键字,标识符</h2><ul>
<li>注释和分类<ul>
<li>注释: 对程序进行解释说明的内容,不作为程序运行的一部分.</li>
<li>注释的作用: </li>
</ul>
<ol>
<li>注销暂时不运行的代码;</li>
<li>对当前运行的代码进行文字说明;</li>
</ol>
<ul>
<li>注释的分类:<ul>
<li>单行注释: <code>//</code></li>
<li>多行注释: <code>/* 注释的内容,里面可换行 */</code></li>
<li>文档注释: <code>/** 注释的内容 */</code><ul>
<li>文档注释可以使用<code>javadoc.exe</code>命令生成API文档</li>
</ul>
</li>
</ul>
</li>
<li>关键字:  <ul>
<li>Java中的基本语句,在编辑器中常被高亮显示</li>
<li>Java关键字都是小写字母单词组成的</li>
</ul>
</li>
<li>标识符:  <ul>
<li>定义: 用于给类,接口,变量,方法,常量起名字的字符序列</li>
<li>组成: 英文大小写<code>a-zA-Z</code>; 数字<code>0-9</code>; 特殊符号<code>$</code>  <code>_</code></li>
<li>注意: <code>$</code> 常用于系统生成的标识符中,自己最好不要使用这个符号</li>
</ul>
</li>
<li>标识符规则:  <ol>
<li>标识符不能和关键字相同</li>
<li>标识符不能以数字开头</li>
<li>标识符严格区分大小写</li>
</ol>
</li>
<li>标识符命名习惯:  <ul>
<li>类和接口: 帕斯卡(pascal)命名法: 大大大(每个单词的首字母都要大写) eg: <code>MyTest</code></li>
<li>变量和方法: 骆驼(camel)命名法: 小大大(首单词小写后面单词首字母大写) eg: <code>personName</code></li>
<li>常量,字段: 所有字母大写,单词和单词之间使用下划线分割 eg: <code>PI</code> <code>MAX_VALUE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="程序概述"><a href="#程序概述" class="headerlink" title="程序概述"></a>程序概述</h3><p>程序: 数据 + 逻辑<br>软件: - “数据”;<br>    |_ “处理数据的逻辑”;<br><strong>通常数据会发生变化,但是数据逻辑时不发生变化的</strong>.</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>基本数据类型<ul>
<li>字节类型: <code>byte</code></li>
<li>整数类型: <code>short</code> , <code>int</code> , <code>long</code></li>
<li>小数类型: <code>float</code> , <code>double</code></li>
<li>字符类型: <code>char</code></li>
<li>布尔类型: <code>boolean</code><ul>
<li>布尔类型的数据值是: <code>true</code> 和 <code>false</code></li>
</ul>
</li>
</ul>
</li>
<li>引用数据类型(后面会详细讲)<ul>
<li>字符串类型: <code>String</code><ul>
<li>注意大小写</li>
</ul>
</li>
<li>数组类型: </li>
<li>类类型:</li>
<li>接口类型:</li>
<li>注意: 在Java中,<code>基本数据类型</code>的类型名都是首字母小写单词;<code>引用数据类型</code>的类型名都是首字母大写的单词;  </li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;呐~这套&lt;code&gt;Java笔记&lt;/code&gt;是博主在学习&lt;strong&gt;Java基础&lt;/strong&gt;期间
    
    </summary>
    
      <category term="笔记" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://duruonanni.com/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="笔记" scheme="http://duruonanni.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件突破百度云限速方法</title>
    <link href="http://duruonanni.com/Chrome%E6%8F%92%E4%BB%B6%E7%AA%81%E7%A0%B4%E7%99%BE%E5%BA%A6%E4%BA%91%E9%99%90%E9%80%9F%E6%96%B9%E6%B3%95/20170529.html"/>
    <id>http://duruonanni.com/Chrome插件突破百度云限速方法/20170529.html</id>
    <published>2017-05-29T12:27:00.000Z</published>
    <updated>2017-05-29T13:58:48.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><p>呐,今年6月1日(也就是大后天)开始,<a href="http://www.tmtpost.com/2606559.html" title="百度网盘6月1日起实行实名制，未认证将遭强退" target="_blank" rel="external">百度就全面强制实行账号实名制</a>了.嗯……<br>好吧,闲话不多说,这就奉上迟到的:迂回突破百度云限制方法.🐱‍💻  </p>
<ul>
<li>本教程仅适用于<strong>Chrome内核浏览器</strong><ul>
<li>查看是否为该内核,只要进入<code>浏览器设置</code>-<code>关于页面</code>,显示<code>Chromium</code>,就对啦</li>
<li>eg: <a href="https://www.centbrowser.com/" title="centbrowser" target="_blank" rel="external">centbrowser</a><br><img src="http://storage.live.com/items/AEE68C12565C1619!174701?authkey=AJoh90nl3u6Wj4U" alt="centbrowser">  </li>
</ul>
</li>
</ul>
<p>本教程参考了:<a href="http://bbs.kafan.cn/thread-2088255-1-1.html" title="突破百度云限速最新方法" target="_blank" rel="external">卡饭论坛:2017 突破百度云限速最新方法</a>  </p>
<h3 id="本教程相对原教程的区别"><a href="#本教程相对原教程的区别" class="headerlink" title="本教程相对原教程的区别:"></a>本教程相对原教程的区别:</h3><ul>
<li><strong>无需科学上网</strong>进入Google WebStore(插件商店)下载User-Agent Switcher插件;<ul>
<li>因为我已经下载并打包好插件了,免翻墙,直接安装即可下载</li>
<li>当前User-Agent Switcher版本为1.0.43_0</li>
<li>下载User-Agent Switcher点 <a href="http://storage.live.com/items/AEE68C12565C1619!174699?authkey=AJoh90nl3u6Wj4U" title="插件下载地址" target="_blank" rel="external">这里</a></li>
</ul>
</li>
<li><strong>无需安装IDM下载器</strong><ul>
<li>要知道IDM的确很强大,但它并不是一款免费软件哦,建议有需要的同学支持正版;<ul>
<li>还是不用吧,正版相当贵(对我来说是)…</li>
</ul>
</li>
<li>所以,这里将使用浏览器自带的下载器;</li>
<li>需要更强大下载功能(断点续传…)的同学,建议安装<a href="http://www.eagleget.com/" target="_blank" rel="external">eagleget</a>软件;  </li>
</ul>
</li>
</ul>
<h3 id="本教程原理推测"><a href="#本教程原理推测" class="headerlink" title="本教程原理推测:"></a>本教程原理推测:</h3><p>私以为,百度云对Windows下的浏览器在下载文件超过一定大小和数量会触发强制使用百度云客户端下载,再对客户端的下载限速.而百度云网页版对Mac Safari浏览器更友好,限制更低.<br>本教程原理推测是,通过使用插件模拟Safari浏览器获得百度云网页版的更高权限.  </p>
<h2 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h2><h3 id="1-下载并解压出User-Agent-Switcher插件"><a href="#1-下载并解压出User-Agent-Switcher插件" class="headerlink" title="1.下载并解压出User-Agent Switcher插件"></a>1.下载并解压出<code>User-Agent Switcher</code>插件</h3><p>插件下载地址: <a href="http://storage.live.com/items/AEE68C12565C1619!174699?authkey=AJoh90nl3u6Wj4U" target="_blank" rel="external">http://storage.live.com/items/AEE68C12565C1619!174699?authkey=AJoh90nl3u6Wj4U</a> </p>
<h3 id="2-打开浏览器扩展管理窗口"><a href="#2-打开浏览器扩展管理窗口" class="headerlink" title="2.打开浏览器扩展管理窗口"></a>2.打开浏览器<strong>扩展管理</strong>窗口</h3><p><img src="http://storage.live.com/items/AEE68C12565C1619!174707:/baiduyun_2.png?authkey=AJoh90nl3u6Wj4U" alt="baiduyunjiasu_2"></p>
<h3 id="3-将解压出的1-0-43-0-crx插件拖拽至浏览器扩展管理窗口中"><a href="#3-将解压出的1-0-43-0-crx插件拖拽至浏览器扩展管理窗口中" class="headerlink" title="3.将解压出的1.0.43_0.crx插件拖拽至浏览器扩展管理窗口中"></a>3.将解压出的<code>1.0.43_0.crx</code>插件拖拽至浏览器<strong>扩展管理</strong>窗口中</h3><p>拖拽后效果如图:<br><img src="http://storage.live.com/items/AEE68C12565C1619!174708:/baiduyun_3.png?authkey=AJoh90nl3u6Wj4U" alt="baiduyunjiasu_3"></p>
<h3 id="4-点选插件-将其设置为safari"><a href="#4-点选插件-将其设置为safari" class="headerlink" title="4.点选插件,将其设置为safari"></a>4.点选插件,将其设置为<strong>safari</strong></h3><p><img src="http://storage.live.com/items/AEE68C12565C1619!174709:/baiduyun_4.png?authkey=AJoh90nl3u6Wj4U" alt="baiduyunjiasu_4"></p>
<h3 id="5-打开网页版百度云-开始下载吧"><a href="#5-打开网页版百度云-开始下载吧" class="headerlink" title="5.打开网页版百度云,开始下载吧"></a>5.打开网页版百度云,开始下载吧</h3><h2 id="该方法优缺点总结"><a href="#该方法优缺点总结" class="headerlink" title="该方法优缺点总结"></a>该方法优缺点总结</h2><ul>
<li>优点<ol>
<li>安全: 不用安装什么绿色版破解版之流软件;</li>
<li>方便: 全程使用浏览器,甚至百度云网盘的客户端都不用安装哦;</li>
<li>高速: 默认情况下,客户端网速<code>10-30Kpbs</code>,此方法’1-3Mpbs’</li>
</ol>
</li>
<li>缺点<ul>
<li>无法批量下载10个以上文件(应该是百度对浏览器下载做出的限制)<ul>
<li>解决方法: 多次少量下载</li>
</ul>
</li>
<li>使用<code>User-Agent Switcher</code>插件后,无法正常打开一些网站,eg:<a href="http://www.bilibili.com/" target="_blank" rel="external">bilibili</a>  <ul>
<li>解决办法: 不进行下载时关闭该插件  </li>
</ul>
</li>
<li>并没有使用IDM的多断点下载速度快<ul>
<li>IDM真的好贵,能有效加速那么多够用啦,就这样啦</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>喏,就这样~🐱‍👤<br>如有疑问或指正,欢迎评论或给我发邮件哦.</p>
<!-- 参考链接 -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;p&gt;呐,今年6月1日(也就是大后天)开始,&lt;a href=&quot;http://www.tmtpost.com/260
    
    </summary>
    
      <category term="教程" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="百度云" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/%E7%99%BE%E5%BA%A6%E4%BA%91/"/>
    
    
      <category term="教程" scheme="http://duruonanni.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法练习</title>
    <link href="http://duruonanni.com/Markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/20170525.html"/>
    <id>http://duruonanni.com/Markdown语法练习/20170525.html</id>
    <published>2017-05-25T15:47:30.000Z</published>
    <updated>2018-01-03T09:16:20.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><p>本文主要是我在学习Markdown语法之后的总结记录.<br>本文只介绍Markdown的语法,不涉及任何HTML的知识.若觉得网上Markdown教程参杂着HTML等难以理解,相信本文能让大家高效掌握这门简单方便的’博客专用’标记语言.  </p>
<p>喏,开始吧.🐱‍👓</p>
<h2 id="1-Markdown简介"><a href="#1-Markdown简介" class="headerlink" title="1. Markdown简介"></a>1. Markdown简介</h2><p>Markdown是一种兼容HTML的轻量级纯文本标记语言,其作用是在写文章的同时对文字进行排版和布局.<br>常用于自媒体或Bloger撰写记录(如wordpress,ghost,jekyll,hexo都使用这种语言发布文章).<br>Markdown使用一些简单易懂的标记实现对文档的排版,同时也兼容<a href="http://www.markdown.cn/" title="Markdown语法说明" target="_blank" rel="external">HTML</a>的语法.<br>使用markdown语法写出文本的后缀名使<code>.md</code>.<br>本文主要参考了:<a href="http://www.markdown.cn/" title="Markdown语法说明" target="_blank" rel="external">易读易写:Markdown-语法说明</a>.</p>
<p>Markdown一大特点就是是可以兼容HTML的语法.下面在插入一段HTML的<strong>无序列表</strong>进行验证.<br><strong>Test</strong></p>
<ul><br>    <li> This is list 1<br>    </li><li> This is list 2<br></li></ul>

<p><strong>HTML代码</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">&lt;ul&gt;</span></div><div class="line">	<span class="symbol">&lt;li&gt;</span> This <span class="keyword">is</span> <span class="keyword">list</span> <span class="number">1</span></div><div class="line">	<span class="symbol">&lt;li&gt;</span> This <span class="keyword">is</span> <span class="keyword">list</span> <span class="number">2</span></div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<h2 id="2-Markdown编辑器推荐"><a href="#2-Markdown编辑器推荐" class="headerlink" title="2. Markdown编辑器推荐"></a>2. Markdown编辑器推荐</h2><p>对Markdown的初学者,建议使用的编辑器能满足以下要求:  </p>
<ol>
<li>Markdown<strong>语法高亮</strong>,可以在编辑的同时使用不同颜色表明语法的标记;</li>
<li>Markdown<strong>实时预览</strong>,可以在编辑同时预览编写出来格式的成品效果,即写即见;  </li>
<li>预览效果接近博客中呈现的效果;  </li>
</ol>
<p>在此,我推荐的学习用Markdown编辑器是:<br><strong><a href="https://www.zybuluo.com/mdeditor" title="CmdMarkdown" target="_blank" rel="external">CmdMarkdown在线编辑器</a></strong><br>目前,我使用的Markdown编辑器是<a href="https://notepad-plus-plus.org/" title="npp" target="_blank" rel="external">notepad++</a>,搭配一些插件.<br>使用notepad++的原因是:    </p>
<ol>
<li>简洁,我讨厌为了单独的markdown就去下载什么专用编辑器,也不喜欢在线编辑的方式;</li>
<li>习惯,notepad++是很棒的editor,最开始学习HTML我就使用它.它的交互逻辑和外观都让我喜欢;</li>
<li>notepad++可以通过添加markdown的xml语法规则轻松实现语法高亮;</li>
<li>notepad++可以引入<code>MarkdownViwer++</code>插件实现类似<code>CmdMarkdown</code>编辑器类似的双屏预览效果(但是有些语法的预览效果并不好,不过习惯了觉得不用预览也没毛病); <blockquote>
<p>PS: 现在改用<a href="https://code.visualstudio.com/" title="vscode" target="_blank" rel="external">vscode</a>,啦~ </p>
</blockquote>
</li>
</ol>
<p>关于我对notepad++的调教,还是略有心得,就以后再单开一帖进行说明啦~😂</p>
<h2 id="3-Markdown常用语法"><a href="#3-Markdown常用语法" class="headerlink" title="3. Markdown常用语法"></a>3. Markdown常用语法</h2><h3 id="1-文本标题"><a href="#1-文本标题" class="headerlink" title="1). 文本标题"></a>1). <span id="title">文本标题</span></h3><p>通常使用atx形式的语法来标记文本标题,这是指:</p>
<blockquote>
<p>在行首插入 1 到 6 个 <strong>#</strong> ，对应到标题 1 到 6 阶.   </p>
</blockquote>
<p>eg:   </p>
<blockquote>
<h1 id="H1-这是1阶标题"><a href="#H1-这是1阶标题" class="headerlink" title="H1 这是1阶标题"></a>H1 这是1阶标题</h1><h2 id="H2-这是2阶标题"><a href="#H2-这是2阶标题" class="headerlink" title="H2 这是2阶标题"></a>H2 这是2阶标题</h2><h6 id="H6-这是6阶标题"><a href="#H6-这是6阶标题" class="headerlink" title="H6 这是6阶标题"></a>H6 这是6阶标题</h6></blockquote>
<p>markdown:<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># H1 这是<span class="number">1</span>阶标题</div><div class="line">## H2 这是<span class="number">2</span>阶标题</div><div class="line">###### H6 这是<span class="number">6</span>阶标题</div></pre></td></tr></table></figure></p>
<p>att:</p>
<blockquote>
<ul>
<li><code>#</code>后面需要加一个空格</li>
<li>不同阶的标题对应的字体大小与间距不同</li>
<li>网页或阅读器可根据不同阶的标题而自动生成文章目录</li>
<li>不要使用标题语法来改变正文文字大小,会导致文章目录混乱</li>
<li>改变文字颜色和大小,建议使用HTML对应的语法</li>
<li>在<a href="http://www.w3school.com.cn/html/index.asp" title="HTML学习" target="_blank" rel="external">W3schlool</a>可以学到简单的HTML语法,这里就不介绍了哈</li>
</ul>
</blockquote>
<h3 id="2-文本的强调-粗体和斜体"><a href="#2-文本的强调-粗体和斜体" class="headerlink" title="2). 文本的强调(粗体和斜体)"></a>2). 文本的强调(粗体和斜体)</h3><p>Markdown 使用星号<code>*</code>和下划线<code>_</code>作为标记强调字词的符号.  </p>
<blockquote>
<p>被<strong>一</strong>对<code>*</code>或<code>_</code>包围的字词会被转成斜体;<br>被<strong>两</strong>对<code>*</code>或<code>_</code>包围的字词会被转成粗体;  </p>
</blockquote>
<p>eg:</p>
<blockquote>
<p>原文: 雾失楼台，月迷津度，桃源望断无寻处<br>斜体: <em>雾失楼台，月迷津度，桃源望断无寻处</em><br>粗体: <strong>雾失楼台，月迷津度，桃源望断无寻处</strong>  </p>
</blockquote>
<p>markdown:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">斜体: <span class="emphasis">*雾失楼台，月迷津度，桃源望断无寻处*</span></div><div class="line">粗体: <span class="strong">__雾失楼台，月迷津度，桃源望断无寻处__</span></div></pre></td></tr></table></figure></p>
<p>att:</p>
<blockquote>
<ul>
<li>使用星号<code>*</code>和下划线<code>_</code>都可以,但是什么符号开启标签，就要用什么符号结束</li>
<li>Markdown不具备<a href="http://baike.baidu.com/item/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/86397?fromtitle=%E8%BD%AC%E4%B9%89%E7%AC%A6&amp;fromid=6151115" title="转义符" target="_blank" rel="external">转义符</a>,如果你的<code>*</code>和<code>_</code>两边都有空白的话，它们就只会被当成普通的符号.如 * 星号, _ 下划线.</li>
</ul>
</blockquote>
<h3 id="3-文本的换行"><a href="#3-文本的换行" class="headerlink" title="3). 文本的换行"></a>3). 文本的换行</h3><p>和我们常用的txt格式不同,markdown里面不能直接通过一个<code>enter</code>(回车键)换行.它常用的换行语法有两种:</p>
<blockquote>
<ol>
<li>在打算换行的文本后面添加一个空行,也就是连按两下<code>回车键</code>啦;</li>
<li>在打算换行的文本后面加入<strong>两个空格</strong>,再回车换行;  </li>
</ol>
</blockquote>
<p>att: </p>
<blockquote>
<ul>
<li>有些区块元素,如<a href="#title">标题</a>,区块引用,列表等.是单个回车即可换行的 </li>
</ul>
</blockquote>
<h3 id="4-文本的分割线"><a href="#4-文本的分割线" class="headerlink" title="4). 文本的分割线"></a>4). 文本的分割线</h3><p>使用<code>---</code>或<code>***</code>来生成水平分割线<br>eg:<br>《浣溪沙》欧阳修</p>
<hr>
<p>堤上游人逐画船,拍堤春水四垂天.绿杨楼外出秋千<br>白发戴花君莫笑,六么催拍盏频传.人生何处似尊前</p>
<hr>
<p>markdown:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">《浣溪沙》欧阳修</div><div class="line"><span class="emphasis">***</span></div><div class="line">堤上游人逐画船,拍堤春水四垂天.绿杨楼外出秋千  </div><div class="line">白发戴花君莫笑,六么催拍盏频传.人生何处似尊前  </div><div class="line"></div><div class="line"><span class="emphasis">***</span></div></pre></td></tr></table></figure></p>
<p>att:  </p>
<blockquote>
<ul>
<li><code>-</code>或者<code>*</code>连续超过3个就可被识别为分割线;</li>
<li>请务必保证使用分割线的该行中没有其他文本;</li>
<li>因为<code>---</code>还可以表示标题的Setext形式,为避免冲突,建议只使用<code>***</code>语法;</li>
<li>非要使用<code>---</code>,就必须要在它的前后都空一行;</li>
<li>当然,也可以使用HTML语法<code>&lt;br/&gt;</code>实现分割线;</li>
</ul>
</blockquote>
<h3 id="5-区块引用"><a href="#5-区块引用" class="headerlink" title="5). 区块引用"></a>5). <span id="blockquote">区块引用</span></h3><p>区块引用的效果是将文字(通常是说明,引用类文字)放在一个独立的框中,使文本排版更清晰.在不同的编辑器中,区块引用显示的效果略有不同.<br>区块引用的语法是在被引用文字之前添加<code>&gt;</code>符号.<br>eg:<br>这是一段普通文字</p>
<blockquote>
<p>这是一段被区块引用的文字</p>
<blockquote>
<p>区块引用支持多层嵌套,可用<code>&gt;&gt;</code>或更多个<code>&gt;</code>表示  </p>
</blockquote>
</blockquote>
<p>att:</p>
<blockquote>
<p>为避免冲突,在使用<code>&gt;</code>引用后,需添加一个空格再写正文<br>若两块引用之间未添加其他有效元素,这两块引用会默认被放在一个框里<br>跳出引用框的方式是<strong>换行</strong><br>引用中可正常使用markwodn的其他语法  </p>
</blockquote>
<h3 id="6-列表"><a href="#6-列表" class="headerlink" title="6). 列表"></a>6). 列表</h3><p>Markdown 支持有序列表和无序列表.<br>无序列表使用<code>*</code>,<code>+</code>,<code>-</code>标记;<br>有序列表使用数字连英语句号.<br>eg:<br><strong>无序列表</strong></p>
<blockquote>
<ul>
<li>red<ul>
<li>purple</li>
<li>pink</li>
</ul>
</li>
</ul>
<ul>
<li>green</li>
</ul>
<ul>
<li>blue    </li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>有序列表</strong></p>
<ol>
<li>seal</li>
<li>whale</li>
<li>penguin  </li>
</ol>
</blockquote>
<p>markdown:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">**无序列表**</div><div class="line"><span class="meta">&gt;</span><span class="bash"> * red</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">	* purple</span></div><div class="line"><span class="meta">&gt;</span><span class="bash">	* pink</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> - green</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> + blue  </span></div><div class="line"><span class="meta"></span></div><div class="line">&gt;<span class="bash"> **有序列表**</span></div><div class="line">1. seal</div><div class="line">2. whale</div><div class="line">3. penguin</div></pre></td></tr></table></figure></p>
<p>att:</p>
<blockquote>
<ul>
<li>千万记得空格</li>
<li>列表支持多层级嵌套(如上面的无序列表那样),在需要多级嵌套的列表前插入<code>tab</code>(制表键)</li>
</ul>
</blockquote>
<h3 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7). 代码块"></a>7). 代码块</h3><p>代码块实现的效果是将块中的文本以深色方框圈示出来.<br>代码块通常用于标记特定语法元素或成段的代码内容,也可以用来标记任何需要在文本中被突出强调的内容.<br>使用一个一对    <strong> ` </strong>     符号框选行内代码块;<br>使用连续三个一对    <strong> ` </strong>     符号框选多行代码块;<br>eg:  </p>
<blockquote>
<p>行内代码块演示:<br> <code>&lt;code&gt;</code>,<code>&lt;script&gt;</code>,<code>console</code>,<code>printf</code>  </p>
<hr>
<p>多行代码块演示,如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Markdown basic learning from Duruonanni<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello Duruo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>att:</p>
<blockquote>
<ul>
<li><strong> ` </strong>这个符号在键盘上排数字1的左边,注意和<strong> ‘ </strong>(小引号)的区分;</li>
<li><strong>多行代码块</strong>和<strong><a href="#blockquote">区块引用</a></strong>的区别:<blockquote>
<ul>
<li>多行代码块引用的文本会直接显示其符号代码本身,引用中标示的题目,加粗等等排版都不会有效显示出来;</li>
<li>区块引用的文本,其中的标记代码以其产生的效果呈现;</li>
<li>在多数编辑器中,使用多行代码块产生的区块默认会在其开头自动添加行号;</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8). 超链接"></a>8). 超链接</h3><p>Markdown 中输入的网址能<strong>自动转换成可点击的形式</strong>.此外,Markdown 还 支持两种形式的链接语法： <strong>行内式</strong>和<strong>参考式</strong>两种形式.<br>两种方法中,链接文字都使用<strong>[方括号]</strong>来标记.  </p>
<h4 id="行内式超链接语法举例"><a href="#行内式超链接语法举例" class="headerlink" title="行内式超链接语法举例:"></a><strong>行内式</strong>超链接语法举例:</h4><p><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.</code><br>效果如下:<br>This is <a href="http://duruonanni.github.io" title="Title" target="_blank" rel="external">an example</a> inline link.</p>
<h4 id="行内式超链接语法详解"><a href="#行内式超链接语法详解" class="headerlink" title="行内式超链接语法详解:"></a><strong>行内式</strong>超链接语法详解:</h4><ul>
<li>[]中括号中的内容为超链接文字</li>
<li>()小括号前部分为超链接地址</li>
<li>()小括号后部分为对链接的说明,可省略,前后部分用空格区分  </li>
<li>链接说明必须用双引号或单引号或括号包围起来(就统一用双引号吧)</li>
</ul>
<hr>
<h4 id="参考试超链接语法举例"><a href="#参考试超链接语法举例" class="headerlink" title="参考试超链接语法举例:"></a><strong>参考试</strong>超链接语法举例:</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">I get 10 times more traffic from [<span class="string">Bing</span>][<span class="symbol">1</span>] than from</div><div class="line">[<span class="string">Yahoo</span>][<span class="symbol">2</span>] or [<span class="string">apple</span>][<span class="symbol">3</span>].</div><div class="line"></div><div class="line"><span class="code">	[1]: http://www.bing.com       "Bing"</span></div><div class="line"><span class="code">	[2]: http://search.yahoo.com/  "Yahoo Search"</span></div><div class="line"><span class="code">	[3]: http://apple.com 	"apple"</span></div></pre></td></tr></table></figure>
<p>效果如下:<br>I get 10 times more traffic from <a href="http://www.markdown.cn/" title="Markdown语法说明" target="_blank" rel="external">Bing</a> than from<a href="https://zh.wikipedia.org/wiki/HTML" title="HTML" target="_blank" rel="external">Yahoo</a> or <a href="http://baike.baidu.com/item/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/86397?fromtitle=%E8%BD%AC%E4%B9%89%E7%AC%A6&amp;fromid=6151115" title="转义符" target="_blank" rel="external">Apple</a>.  </p>
<h4 id="参考试超链接语法详解"><a href="#参考试超链接语法详解" class="headerlink" title="参考试超链接语法详解:"></a><strong>参考试</strong>超链接语法详解:</h4><ul>
<li>在正文中,前面一个[]中括号放超链接文字</li>
<li>后面一个[]中括号中放这个超链接文字对应的编号</li>
<li>后面的说明不会出现在正文中,其以编号对应超链接指向的地址</li>
<li>使用参考试的超链接可重复定义,只要标号相同即可</li>
<li>链接的说明内容可以集中放在文章末尾,像论文的参考文献那样</li>
<li>建议多使用<strong>参考试</strong>超链接</li>
</ul>
<h3 id="9-图片"><a href="#9-图片" class="headerlink" title="9). 图片"></a>9). 图片</h3><p>Markdown支持通过超链接插入图片,具体的语法如下:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="string">douwei_shanheshui</span>](<span class="link">http://storage.live.com/items/AEE68C12565C1619!174692:/douwei_shanheshui.jpg?authkey=AJoh90nl3u6Wj4U "山河水.窦唯"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="插入图片语法说明"><a href="#插入图片语法说明" class="headerlink" title="插入图片语法说明:"></a>插入图片语法说明:</h4><ul>
<li>首先一个叹号!</li>
<li>接着一个[]方括号,在其中键入图片的替代文字(就是图片失效时显示的替代文字)</li>
<li>最后跟()小括号,前半部分是引用图片的地址</li>
<li>()小括号中,后半部分引号包起来的是对图片的说明,可省略  </li>
</ul>
<h4 id="以上插入图片举例的效果如下"><a href="#以上插入图片举例的效果如下" class="headerlink" title="以上插入图片举例的效果如下:"></a>以上插入图片举例的效果如下:</h4><p><img src="http://storage.live.com/items/AEE68C12565C1619!174692:/douwei_shanheshui.jpg?authkey=AJoh90nl3u6Wj4U" alt="douwei_shanheshui">  </p>
<h4 id="att"><a href="#att" class="headerlink" title="att:"></a>att:</h4><ul>
<li>此法插入的图片,无法调整位置和大小,若需要调整,请自行学习HTML对应语法</li>
<li>此法插入图片的路径,可以是一个url地址,可以是文本所在文件夹的相对位置</li>
<li>若使用markdown写的带图文章需要发布在网上,建议将使用<a href="http://baike.baidu.com/item/%E5%9B%BE%E5%BA%8A" title="图床介绍" target="_blank" rel="external">图床</a>生成图片链接</li>
<li>本文使用<strong>Onedrive</strong>做图床</li>
</ul>
<h3 id="9-非常用标记"><a href="#9-非常用标记" class="headerlink" title="9). 非常用标记"></a>9). 非常用标记</h3><p>下面简单介绍几个Markdown中我认为的不重要的非常用标记:  </p>
<h4 id="9-1-表格"><a href="#9-1-表格" class="headerlink" title="9.1 表格"></a>9.1 表格</h4><p>是的,Markdown可以用来生成简单的表格,其生成的表格效果如下:  </p>
<table>
<thead>
<tr>
<th>浓香型</th>
<th style="text-align:center">酱香型</th>
<th style="text-align:right">清香型</th>
<th style="text-align:center">米香型</th>
</tr>
</thead>
<tbody>
<tr>
<td>五粮液</td>
<td style="text-align:center">茅 台</td>
<td style="text-align:right">汾 酒</td>
<td style="text-align:center">三花酒</td>
</tr>
<tr>
<td>泸州老窖</td>
<td style="text-align:center">郎 酒</td>
<td style="text-align:right">二锅头</td>
<td style="text-align:center">冰峪庄园</td>
</tr>
<tr>
<td>首行是</td>
<td style="text-align:center">表格标题</td>
<td style="text-align:right">注意观察</td>
<td style="text-align:center">对齐方向</td>
</tr>
</tbody>
</table>
<p>对应的语法如下:<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|<span class="string"> 浓香型 </span>|<span class="string"> 酱香型 </span>|<span class="string"> 清香型 </span>|<span class="string"> 米香型 </span>|</div><div class="line">|<span class="string"> ------ </span>|<span class="string"> :----: </span>|<span class="string"> -----: </span>|<span class="string"> :----: </span>|</div><div class="line">|<span class="string"> 五粮液 </span>|<span class="string"> 茅 台  </span>|<span class="string"> 汾 酒  </span>|<span class="string"> 三花酒 </span>|</div><div class="line">|<span class="string"> 泸州老窖 </span>|<span class="string"> 郎 酒 </span>|<span class="string"> 二锅头 </span>|<span class="string"> 冰峪庄园 </span>|</div></pre></td></tr></table></figure></p>
<p>说明:</p>
<ul>
<li>使用<code>|</code>对表格进行划分,表格与内容之间用<strong>空格</strong>隔开</li>
<li><code>------:</code>为右对齐;<code>:-----</code>为左对齐;<code>:----:</code>为居中对齐</li>
<li>默认使用居中对齐,对齐方式对该列有效</li>
<li>写在对齐方式上排的是标题,默认会加粗</li>
<li>在不同编辑器中对这种表格的兼容性不同</li>
<li>这种制表的方法其实比较简陋,所以不建议使用这种制表方式</li>
<li>制表格,建议使用HTML对应的语法  </li>
</ul>
<h4 id="9-2-Todolist-待办事项"><a href="#9-2-Todolist-待办事项" class="headerlink" title="9.2 Todolist(待办事项)"></a>9.2 Todolist(待办事项)</h4><p>是的,Markdown可以生成Todolist,其生成的效果如下:  </p>
<ul>
<li>[ ] Markdown-语法说明<ul>
<li>[x] Markdown简介</li>
<li>[x] Markdown常用语法说明</li>
<li>[ ] Markdown 编辑器</li>
</ul>
</li>
<li>[ ] 纯<code>Javascript</code>编写<code>1024</code>小游戏  </li>
</ul>
<p>对应语法如下:<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> [ ] Markdown-语法说明</span></div><div class="line">	-<span class="ruby"> [x] Markdown简介</span></div><div class="line">	-<span class="ruby"> [x] Markdown常用语法说明</span></div><div class="line">	-<span class="ruby"> [ ] Markdown 编辑器</span></div><div class="line">-<span class="ruby"> [ ] 纯<span class="string">`Javascript`</span>编写<span class="string">`1024`</span>小游戏</span></div></pre></td></tr></table></figure></p>
<p>说明:</p>
<ul>
<li>看例子应该很好理解,就不长谈了.就这样啦~</li>
</ul>
<h4 id="9-3-更不常用的标记"><a href="#9-3-更不常用的标记" class="headerlink" title="9.3 更不常用的标记"></a>9.3 更不常用的标记</h4><p>此外,Markdown还可以制作,流程图,序列图,甘特图等等等.<br>但是这些并不常用,在此就暂且略过啦~</p>
<h2 id="3-学完Markdown后做什么"><a href="#3-学完Markdown后做什么" class="headerlink" title="3. 学完Markdown后做什么"></a>3. 学完<strong>Markdown</strong>后做什么</h2><p>学完Markdown,当然就可以愉快的在博客中畅所欲言啦.<br>当然,若要实现文章更漂亮的排版(eg:文字的<font color="pink" size="5em">颜色大小</font>啦,图片的大小位置调整啊,文本背景设置啊,等等等).<br>你就需要继续学习<a href="https://zh.wikipedia.org/wiki/HTML" title="HTML" target="_blank" rel="external">HTML</a>和<a href="http://baike.baidu.com/item/CSS/5457?fromtitle=%E7%BA%A7%E8%81%94%E6%A0%B7%E5%BC%8F%E8%A1%A8&amp;fromid=4312047" title="CSS介绍" target="_blank" rel="external">CSS</a>了.<br>此外,要实现一些诸如<strong>自动插入文章字数,写文章时间等</strong>,你还需要学一些基础的<a href="http://baike.baidu.com/item/javascript" title="javascript" target="_blank" rel="external">JavaScript</a>脚本.<br>路漫漫其修远兮,照着这个既定的路径,就会在技术求索的路上停不下来了.  </p>
<p>喏,就这样吧~🐱‍👤</p>
<!-- 参考文献 -->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;p&gt;本文主要是我在学习Markdown语法之后的总结记录.&lt;br&gt;本文只介绍Markdown的语法,不涉及任何H
    
    </summary>
    
      <category term="教程" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="markdown" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/markdown/"/>
    
    
      <category term="教程" scheme="http://duruonanni.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo建站流程</title>
    <link href="http://duruonanni.com/%E5%BB%BA%E7%AB%99%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/20170509.html"/>
    <id>http://duruonanni.com/建站流程记录/20170509.html</id>
    <published>2017-05-08T16:20:40.797Z</published>
    <updated>2017-05-26T09:03:52.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><p>本文是笔者在搭建本站时收集记录的建站过程.在搭建过程中,由于相关知识的匮缺,看不懂一些教程中省略的部分或是一些专业术语,走了一些弯路.但磕绊终究是成功建好了本站.也有了此小文.<br><strong>本文适用于对Hexo建站感兴趣但畏惧专业术语的非科班出身同学.我其中对一些网上多数教程稍省略不清楚的地方进行了解释.</strong> 希望能帮助到需要的人.<br><em>由于笔者也只是前端和建站的初学者,多有不足之处,还望批评指正.</em>  </p>
<h3 id="本文主要参考了"><a href="#本文主要参考了" class="headerlink" title="本文主要参考了:"></a>本文主要参考了:</h3><blockquote>
<ul>
<li>Setsuna’s Blog : <a href="http://www.isetsuna.com/hexo/introduction/" title="Hexo博客系列" target="_blank" rel="external">Hexo博客系列</a></li>
<li>up主:SnowHotarubi的视频教程 : <a href="http://www.bilibili.com/video/av9185310" title="搭载个人网站竟如此简单" target="_blank" rel="external">搭载个人网站竟如此简单系列</a></li>
<li><a href="https://hexo.io" title="hexo官方文档" target="_blank" rel="external">hexo官方文档</a>  </li>
</ul>
</blockquote>
<h3 id="我使用的软件版本"><a href="#我使用的软件版本" class="headerlink" title="我使用的软件版本:"></a>我使用的软件版本:</h3><table>
<thead>
<tr>
<th style="text-align:center">softwares</th>
<th style="text-align:center">edition</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OS</td>
<td style="text-align:center">Windows 10-x64 10563 创意者更新正式版</td>
</tr>
<tr>
<td style="text-align:center">Node.js</td>
<td style="text-align:center">v6.10.2-x64</td>
</tr>
<tr>
<td style="text-align:center">git</td>
<td style="text-align:center">2.12.2.2-x64</td>
</tr>
<tr>
<td style="text-align:center">hexo</td>
<td style="text-align:center">3.3.5</td>
</tr>
</tbody>
</table>
<h2 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一. 环境搭建"></a>一. 环境搭建</h2><h3 id="1-下载并安装-Node-js"><a href="#1-下载并安装-Node-js" class="headerlink" title="1) 下载并安装 Node.js"></a>1) 下载并安装 <a href="https://nodejs.org/en/" title="Node.js" target="_blank" rel="external">Node.js</a></h3><h3 id="2-下载并安装git"><a href="#2-下载并安装git" class="headerlink" title="2) 下载并安装git"></a>2) 下载并安装<a href="https://git-scm.com" title="git" target="_blank" rel="external">git</a></h3><p>说明: </p>
<blockquote>
<ul>
<li>以上<code>Node.js</code>是Hexo需要的运行环境;<code>git</code>用于网站的发布与托管.</li>
<li>以上两个软件,下载后全部按照默认要求安装即可.  </li>
</ul>
</blockquote>
<p>ATT: </p>
<blockquote>
<ul>
<li>若git安装完成后在<strong>文件管理器</strong>中右键无<code>Git bash here</code>选项,参考此教程:<em><a href="http://blog.csdn.net/u014527912/article/details/51723735" title="右键添加gitbash" target="_blank" rel="external">右键-添加Git Bash Here菜单</a></em>  </li>
</ul>
</blockquote>
<h2 id="二-Hexo的安装和blog文件夹的初始化"><a href="#二-Hexo的安装和blog文件夹的初始化" class="headerlink" title="二. Hexo的安装和blog文件夹的初始化"></a>二. Hexo的安装和blog文件夹的初始化</h2><h3 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1) 安装hexo"></a>1) 安装hexo</h3><p>方法: </p>
<blockquote>
<ul>
<li>打开新安装的<code>git bash</code>软件,在其中输入    <code>npm install hexo-cli -g</code>,<strong>回车确认</strong>  </li>
</ul>
</blockquote>
<p>ATT:</p>
<blockquote>
<ul>
<li>在<code>git bash</code>中输入的所有代码都要以<strong>回车确认</strong>才有效;</li>
<li>可为避免输入错误,可直接复制此代码,在<code>git bash</code>中以<strong>shift+insert</strong>组合键粘贴;</li>
<li>检查是否安装成功,可输入 <code>Hexo version</code>(显示Hexo版本则安装成功);</li>
<li>遇到提示<code>Local hexo not found in ~</code>问题,继续输入:<code>npm install hexo --save</code>;</li>
</ul>
</blockquote>
<h3 id="2-新建blog文件夹"><a href="#2-新建blog文件夹" class="headerlink" title="2) 新建blog文件夹"></a>2) 新建<code>blog</code>文件夹</h3><p>方法:  </p>
<blockquote>
<p>电脑适当位置新建一个blog文件夹(也可以命名为其他,本文全使用blog代指此文件夹),用于存放Hexo博客相关文件;  </p>
</blockquote>
<h3 id="3-在git-bash中选定blog文件夹"><a href="#3-在git-bash中选定blog文件夹" class="headerlink" title="3) 在git bash中选定blog文件夹"></a>3) 在<code>git bash</code>中选定<code>blog</code>文件夹</h3><blockquote>
<ul>
<li>选定方法一: 在该文件管理器中的该文件夹内鼠标右键点击<strong>Git Bash Here</strong></li>
<li>选定方法二: 在git bash中输入文件夹的绝对路径,eg:<code>cd c:/cusumerfiles/blog</code>( cd [blog文件夹位置] )  </li>
</ul>
</blockquote>
<h3 id="4-初始化blog文件夹"><a href="#4-初始化blog文件夹" class="headerlink" title="4) 初始化blog文件夹"></a>4) 初始化<code>blog</code>文件夹</h3><p>方法:    </p>
<blockquote>
<ul>
<li>在<code>git bash</code>中输入: <code>hexo init</code>  </li>
</ul>
</blockquote>
<p>ATT: </p>
<blockquote>
<ul>
<li>初始化完成后,文件夹内会多出一些文件  </li>
</ul>
</blockquote>
<h3 id="5-安装npm"><a href="#5-安装npm" class="headerlink" title="5) 安装npm"></a>5) 安装npm</h3><p>方法:    </p>
<blockquote>
<ul>
<li>在<code>git bash</code>中输入: <code>npm install</code>    </li>
</ul>
</blockquote>
<p>至此,Hexo安装完成  </p>
<h3 id="6-在本地预览博客效果"><a href="#6-在本地预览博客效果" class="headerlink" title="6) 在本地预览博客效果"></a>6) 在本地预览博客效果</h3><p>方法:    </p>
<blockquote>
<ul>
<li>在<code>git bash</code>中输入: <code>hexo server</code></li>
<li>在浏览器中打开 <strong> <a href="http://loacalhost:4000" target="_blank" rel="external">http://loacalhost:4000</a> </strong> 即可预览默认博客页面</li>
<li>在git Bash中输入<strong>ctrl+c</strong>退出预览</li>
</ul>
</blockquote>
<h2 id="三-Hexo的基本配置"><a href="#三-Hexo的基本配置" class="headerlink" title="三. Hexo的基本配置"></a>三. Hexo的基本配置</h2><p>此配置涉及到<strong>网址</strong>,<strong>网站名称</strong>,<strong>拥有者</strong>,<strong>文章发布形式</strong>等信息.<br>方法:  </p>
<blockquote>
<ul>
<li>在Blog根目录下,找到<code>_config.yml</code>文件.使用文本编辑器打开(推荐使用<a href="https://notepad-plus-plus.org" title="notepad++" target="_blank" rel="external">notepad++</a>或者<a href="http://www.sublimetext.com/" title="sublime" target="_blank" rel="external">sublime Text 3</a>软件)进行设置</li>
<li>配置的具体方法见本站:<a href="https://duruonanni.github.io/blog/Hexo站点设置/20170508/" title="Hexo站点设置" target="_blank" rel="external">Hexo站点设置</a></li>
</ul>
</blockquote>
<h2 id="四-Hexo主题设置"><a href="#四-Hexo主题设置" class="headerlink" title="四.    Hexo主题设置"></a>四.    Hexo主题设置</h2><p>Hexo的特点就是拥有许多或清新或绚丽的主题(自带的主题名称叫<code>landscape</code>),选择一款中意的主题,进行一些简单的设置,就能让博客更加赏心悦目.以下是主题设置的方法,本文以<code>NexT</code>主题为例设置:  </p>
<h3 id="1-进入Hexo官方主题商店预览-选定喜欢的主题"><a href="#1-进入Hexo官方主题商店预览-选定喜欢的主题" class="headerlink" title="1) 进入Hexo官方主题商店预览,选定喜欢的主题"></a>1) 进入<a href="https://hexo.io/themes/" title="Hexo官方主题商店" target="_blank" rel="external">Hexo官方主题商店</a>预览,选定喜欢的主题</h3><blockquote>
<ul>
<li>以NexT主题为例 主题详情页: <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html</a></li>
<li>主题样式预览页: <a href="http://notes.iissnan.com/" target="_blank" rel="external">http://notes.iissnan.com/</a>  </li>
</ul>
</blockquote>
<h3 id="2-NexT主题安装"><a href="#2-NexT主题安装" class="headerlink" title="2) NexT主题安装"></a>2) NexT主题安装</h3><blockquote>
<ul>
<li>在将<code>git bash</code>定位到blog文件夹,键入:<br>  <code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code>.<br>  成功则将会在blog-&gt;themes文件夹下新建next文件夹  </li>
<li>ATT: 务必保存一个next文件夹内的 <code>_config.yml</code>文件备份.  </li>
</ul>
</blockquote>
<h3 id="3-NexT主题启用"><a href="#3-NexT主题启用" class="headerlink" title="3) NexT主题启用"></a>3) NexT主题启用</h3><blockquote>
<ul>
<li><p>使用文本编辑器打开<code>blog</code>下的<code>config.yml</code>,找到<code>theme</code>字段,将原始值<code>landscape</code>用<code>#</code>注释掉(方便今后需要时候找回),新建主题<code>theme: next</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 主题</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></div><div class="line"><span class="meta">#</span><span class="bash">theme: <span class="literal">false</span> <span class="comment">#禁用主题</span></span></div><div class="line"><span class="meta">#</span><span class="bash">theme: landscape <span class="comment">#默认主题</span></span></div><div class="line">theme: next</div></pre></td></tr></table></figure>
</li>
<li><p>ATT: 在切换主题之后,验证之前,最好使用<code>hexo clean</code> 来清除Hexo的缓存  </p>
</li>
</ul>
</blockquote>
<h3 id="4-调试新主题"><a href="#4-调试新主题" class="headerlink" title="4) 调试新主题"></a>4) 调试新主题</h3><blockquote>
<ul>
<li>使用Hexo的本地调试模式验证新主题效果,在<code>git bash</code>中输入:<code>hexo server --debug</code></li>
<li>在浏览器打开: <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 验证主题是否正常使用  </li>
<li>调试完成后,在<code>git bash</code>中键入<code>ctrl+c</code>快捷键组合取消调试</li>
</ul>
</blockquote>
<h3 id="5-主题详细设置"><a href="#5-主题详细设置" class="headerlink" title="5) 主题详细设置"></a>5) 主题详细设置</h3><blockquote>
<ul>
<li>详见<a href="http://theme-next.iissnan.com/getting-started.html" title="NexT主题文档" target="_blank" rel="external">Next主题的官方文档</a>  </li>
<li><p>之后我也会写一个自己站点的主题设置方案,暂时todo list 吧~  </p>
</li>
<li><p>ATT:在设置主题时,可打开了Hexo本地调试模式(<code>hexo server</code>),在设定主题效果后,即刻保存相应的<strong>config.yml</strong>文件并刷新浏览器,可在浏览器即刻上预览更改的效果.取消调试在在<code>git bash</code>中键入<code>ctrl+c</code>快捷键  </p>
</li>
</ul>
</blockquote>
<h2 id="五-Hexo插件设置"><a href="#五-Hexo插件设置" class="headerlink" title="五. Hexo插件设置"></a>五. Hexo插件设置</h2><p>通过插件可为站点添加: <strong>显示运行时间</strong>,<strong>日历</strong>,<strong>添加RSS</strong>,<strong>添加友链</strong>等功能.  </p>
<blockquote>
<ul>
<li>hexo插件位于: blog/node_modules 目录下</li>
<li>官方插件详情地址是: <a href="http://hexo.io/plugins/" target="_blank" rel="external">http://hexo.io/plugins/</a>  </li>
</ul>
</blockquote>
<h2 id="六-将网站托管到Github-pages"><a href="#六-将网站托管到Github-pages" class="headerlink" title="六. 将网站托管到Github pages"></a>六. 将网站托管到Github pages</h2><p><a href="https://github.com" title="github" target="_blank" rel="external">Github</a>是全球最大的开源程序托管平台,有无数极具创造力和分享精神的<code>Programmers</code> &amp; <code>Engineers</code>在上面创造改变世界的代码.<!--是为数不多的,即便是我国环境下也能顺畅访问的大网站.--><br><a href="https://pages.github.com" title="github pages" target="_blank" rel="external">GitHub pages</a>是<code>github</code>上一个项目,他允许用户实时展示自己的网站与正在进行的项目.<br>我们就将使用<code>GitHub pages</code>对我们本地创建好的<code>Hexo</code>博客网站进行托管和发布.<br>操作完成后,任何人就都可以通过域名在互联网上访问你的网站了.<br>ATT:</p>
<blockquote>
<ul>
<li><code>Github pages</code>是免费的,因此有一些限制,但创建流量不高的个人网站完全够用.具体限制是:<br>  单个仓库大小不超过1GB，上传单个文件大小不能超过100MB，通过浏览器上传不能超过25MB个人网站项目也不例外，最大空间1GB个人网站项目每个月访问请求数不能超过10万次，总流量不能超过100GB个人网站项目一小时创建数量不能超过10个.</li>
<li>可在此网站查看<code>Github pages</code>的使用政策:<br>   <a href="https://help.github.com/articles/what-is-github-pages/#recommended-limits" target="_blank" rel="external">https://help.github.com/articles/what-is-github-pages/#recommended-limits</a></li>
</ul>
</blockquote>
<h3 id="1-注册github账号"><a href="#1-注册github账号" class="headerlink" title="1) 注册github账号"></a>1) 注册github账号</h3><blockquote>
<p>直接进入<a href="https://github.com" title="github" target="_blank" rel="external">Github</a>官网,使用邮箱注册账号即可.  </p>
<p>ATT: 慎重填写<code>Github账号名</code>,这会是你的网站域名.  </p>
</blockquote>
<h3 id="2-配置SSH-keys-建立本地与github的联系"><a href="#2-配置SSH-keys-建立本地与github的联系" class="headerlink" title="2) 配置SSH keys(建立本地与github的联系)"></a><span id="2">2)</span> 配置SSH keys(建立本地与github的联系)</h3><h4 id="①-检查SSH-keys设置"><a href="#①-检查SSH-keys设置" class="headerlink" title="① 检查SSH keys设置"></a>① 检查SSH keys设置</h4><blockquote>
<p>ps: <strong>以下所有的输入均指在<code>git bash</code>中输入</strong>,输入完成请记得<strong>回车</strong>  </p>
<p>在<code>git bash</code>输入:<em>cd ~/.ssh</em>  </p>
</blockquote>
<h4 id="②-生成SSH-key-输入-ssh-keygen-t-rsa-C-“邮件地址-youremail-com”"><a href="#②-生成SSH-key-输入-ssh-keygen-t-rsa-C-“邮件地址-youremail-com”" class="headerlink" title="② 生成SSH key 输入: ssh-keygen -t rsa -C “邮件地址@youremail.com”"></a>② 生成SSH key 输入: ssh-keygen -t rsa -C “邮件地址@youremail.com”</h4><blockquote>
<p>ATT:<br>注意此处区分大小写,那个<code>C</code>是大写  </p>
<p>首次连接会出现key fingerprint警告,输入yes继续<br><code>Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa)</code><br>此处意思是选择密匙存放位置,默认即可,回车继续<br><code>Enter passphrase (empty for no passphrase)</code><br>公匙密码,不需要密码则直接回车</p>
<ul>
<li>若输入了密码,在此处以及确认密码输入时都不会显示明文密码(应该是保护隐私的缘故),继续输入即可.  </li>
<li>请牢记此密码,这是每次发布博客都需要用到的.  </li>
</ul>
<p><code>Enter same passphrase again</code><br>重复确认密码,不需要则直接回车<br><code>Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa.</code><br>私钥保存路径,回车<br><code>Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub.</code><br>公钥保存路径,回车<br>出现 <code>The key fingerprint is:&amp; The key&#39;s randomart image is</code> 说明配置成功<br>出现 <code>You&#39;ve successfully authenticated</code> 则自此配置成功.  </p>
</blockquote>
<h3 id="3-在Github创建-GitHub-Pages-项目"><a href="#3-在Github创建-GitHub-Pages-项目" class="headerlink" title="3) 在Github创建 GitHub Pages 项目"></a>3) 在Github创建 <code>GitHub Pages</code> 项目</h3><h4 id="①-新建仓库"><a href="#①-新建仓库" class="headerlink" title="① 新建仓库"></a>① 新建仓库</h4><blockquote>
<p>方法: 打开浏览器上建好的<code>github</code>账号主页 击右上角+号选择 <code>new reponsitory</code> .(新建仓库)<br><strong>ATT</strong>: 仓库名称<strong>只能</strong>是<code>username.github.io</code>(username为你创建账号的名字,必须完全一致)  </p>
</blockquote>
<h4 id="②-向github添加SSH公匙"><a href="#②-向github添加SSH公匙" class="headerlink" title="② 向github添加SSH公匙"></a>② 向github添加SSH公匙</h4><blockquote>
<p>方法:</p>
<ol>
<li>找到<a href="#2"><strong>2)</strong></a>中配置公匙的路径(参见本文中的默认路径即可),用文本编辑器打开并复制 <code>id_rsa.pub</code>文件中的所有内容.  </li>
<li>打开浏览器中的Github个人主页,依次点击:<code>Settings</code>—&gt;<code>SSH keys</code>—&gt;<code>Add SSH key</code>  </li>
<li>在Title文本框中输入任意字符,在key文本框中粘贴刚才复制的公匙,保存.自此,操作完成.  </li>
</ol>
</blockquote>
<h4 id="③-测试链接"><a href="#③-测试链接" class="headerlink" title="③ 测试链接"></a>③ 测试链接</h4><blockquote>
<p>在git bash中输入: <code>ssh -T git@github.com</code><br>首次连接会出现密钥指纹警告，输入<code>yes</code>回车即可<br>显示 <code>You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>则操作成功  </p>
</blockquote>
<h3 id="4-在Github中创建项目"><a href="#4-在Github中创建项目" class="headerlink" title="4) 在Github中创建项目"></a>4) 在<code>Github</code>中创建项目</h3><h4 id="①-向Hexo安装插件-hexo-deployer-git"><a href="#①-向Hexo安装插件-hexo-deployer-git" class="headerlink" title="① 向Hexo安装插件 hexo-deployer-git"></a>① 向Hexo安装插件 <code>hexo-deployer-git</code></h4><blockquote>
<p>说明: 此插件用于向GitHub部署静态页面<br>方法: 输入: <code>npm install hexo-deployer-git --save</code>  </p>
</blockquote>
<h4 id="②-修改-config-yml文件"><a href="#②-修改-config-yml文件" class="headerlink" title="② 修改_config.yml文件"></a>② 修改<code>_config.yml</code>文件</h4><blockquote>
<p>用文本编辑器打开blog文件夹中的 config.yml文件,下拉至最后找到deploy栏,进行如下修改:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">deploy</span>:  </div><div class="line">   <span class="attribute">type</span>: git (部署类型若有问题，其他类型自行google之)  </div><div class="line">   <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/yourname/yourname.github.io.git  </span></div><div class="line">   (yourname改成你的项目名,注意两个名字必须一致)  </div><div class="line">   <span class="attribute">branch</span>: master</div><div class="line">   <span class="attribute">plugins</span>: -hexo-generator-feed</div></pre></td></tr></table></figure></p>
<p>改完成后保存  </p>
</blockquote>
<h4 id="③-部署网页"><a href="#③-部署网页" class="headerlink" title="③ 部署网页"></a>③ 部署网页</h4><blockquote>
<p>在 git bash 中输入: <code>hexo generate</code>    回车(生成静态网页)<br>在 git bash 继续输: <code>hexo deploy</code>    回车(开始部署网站)  </p>
</blockquote>
<h4 id="④-通过浏览器确定是否部署成功"><a href="#④-通过浏览器确定是否部署成功" class="headerlink" title="④ 通过浏览器确定是否部署成功"></a>④ 通过浏览器确定是否部署成功</h4><blockquote>
<p>在浏览器地址栏输入: <a href="http://yourname.github.io" target="_blank" rel="external">http://yourname.github.io</a>    (yourname为你的项目名)<br>显示hexo默认界面则成功</p>
</blockquote>
<h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>教程有对如何建站进行了讲解.建站的完成,自然意味着博客冒险之路的开始咯.诚然,建站完成之后还有很多工作需要做呢.<br>本文的站点建设,几乎不涉及任何知识点,只是依葫芦画瓢的简单操作.<br>之后,我觉得我们应该至少掌握如下技能:</p>
<ul>
<li>[x] <a href="https://duruonanni.github.io/blog/Hexo%E7%AB%99%E7%82%B9%E8%AE%BE%E7%BD%AE/20170508/" title="hexo站点设置" target="_blank" rel="external">Hexo站点设置</a>,更详细的掌握这个站点的各个功能,让自己的操作更得心应手;  </li>
<li>[x] <a href="https://duruonanni.github.io/blog/Markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/20170525/" title="Markdown" target="_blank" rel="external">Markdown语言的学习</a>,hexo中发布文章就是使用这个语言的,掌握好就能写出漂亮排版的文章;  </li>
<li>[ ] 英语,具备一定的英语基础,对之后的进阶,我认为是最重要的.能做到无障碍阅读英语文献,就能更容易理解编程建站中原理性的问题.<br>最后,若在依照本教程建站时出现任何问题,请留言或邮件联系我.<br>对本站有什么建议,也欢迎<strong>留言</strong>.</li>
</ul>
<p>喏,就这样啦~🐱‍👤</p>
<p><img src="http://storage.live.com/items/AEE68C12565C1619!174695:/Something_Just_Like_This.png?authkey=AJoh90nl3u6Wj4U" alt="somenoe just like this" title="Something_Just_Like_This"></p>
<!--参考文献:(不会出现在正文里)-->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;p&gt;本文是笔者在搭建本站时收集记录的建站过程.在搭建过程中,由于相关知识的匮缺,看不懂一些教程中省略的部分或是一
    
    </summary>
    
      <category term="教程" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/hexo/"/>
    
    
      <category term="教程" scheme="http://duruonanni.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo站点设置</title>
    <link href="http://duruonanni.com/Hexo%E7%AB%99%E7%82%B9%E8%AE%BE%E7%BD%AE/20170508.html"/>
    <id>http://duruonanni.com/Hexo站点设置/20170508.html</id>
    <published>2017-05-08T11:25:01.000Z</published>
    <updated>2017-05-26T09:04:42.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h2><p>本文主要结合我建站时的经历,对配置Hexo的<code>_config.yml</code>文件配置说明,以及hexo的常用指令的介绍.<br>本文适用于已通过各路Hexo教程完成建站后,需要了解Hexo站点设置的同学.若尚未完成建站,请先行阅读<strong><a href="https://duruonanni.github.io/blog/%E5%BB%BA%E7%AB%99%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/20170509/" title="Hexo建站流程" target="_blank" rel="external">todo:建站流程记录</a></strong>.<br>本文内容主要参考了:  </p>
<ul>
<li>Setsuna’s Blog:<a href="http://www.isetsuna.com/hexo/install-config/" title="Hexo博客系列" target="_blank" rel="external">Hexo博客系列</a>  </li>
<li>张学志の博客:<a href="http://blog.csdn.net/xuezhisdc/article/details/53130383" title="hexo配置教程" target="_blank" rel="external">hexo配置教程</a>  </li>
<li><a href="https://hexo.io/zh-cn/docs/configuration.html" title="hexo官方文档" target="_blank" rel="external">hexo官方文档</a><br>在此一并感谢~  </li>
</ul>
<p>由于笔者也是前端与建站的初学者,技浅才疏.如有错误或不足,还望批评指正~</p>
<h2 id="一-Blog文件夹详解"><a href="#一-Blog文件夹详解" class="headerlink" title="一. Blog文件夹详解"></a>一. Blog文件夹详解</h2><!--参考:https://hexo.io/zh-cn/docs/setup.html -->
<p>att:  </p>
<blockquote>
<ul>
<li><code>Blog</code>文件夹是我的Hexo初始化根目录名称</li>
<li>下面目录中<code>#</code>之后的内容是我写的注释,用于解释各个文件及文件夹的作用<h3 id="建站成功后-Blog文件夹内可见如下目录"><a href="#建站成功后-Blog文件夹内可见如下目录" class="headerlink" title="建站成功后,Blog文件夹内可见如下目录:"></a>建站成功后,Blog文件夹内可见如下目录:</h3></li>
</ul>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml 	<span class="meta"># Hexo的配置文件</span></div><div class="line">├── <span class="keyword">package</span>.json 	<span class="meta"># Hexo版本信息及插件信息</span></div><div class="line">├── .deploy_git 	<span class="meta"># </span></div><div class="line">├── node_modules 	<span class="meta"># </span></div><div class="line">├── <span class="keyword">public</span> 	<span class="meta"># 存放souce文件夹解析出的文件</span></div><div class="line">├── scaffolds 	<span class="meta"># 模板文件夹</span></div><div class="line">├── source 	<span class="meta"># 资源文件夹</span></div><div class="line">|   ├── _drafts <span class="meta"># 存放md格式的草稿文章,默认不发布草稿</span></div><div class="line">|   └── _posts <span class="meta"># 存放用于发布的md格式文章</span></div><div class="line">└── themes 	<span class="meta"># 主题文件</span></div></pre></td></tr></table></figure>
<h2 id="二-Hexo的-config-yml配置详解"><a href="#二-Hexo的-config-yml配置详解" class="headerlink" title="二. Hexo的_config.yml配置详解"></a>二. Hexo的_config.yml配置详解</h2><!-- 参考1:https://hexo.io/zh-cn/docs/configuration.html -->
<!--参考2:http://blog.csdn.net/xuezhisdc/article/details/53130383 -->
<h3 id="配置前的说明"><a href="#配置前的说明" class="headerlink" title="配置前的说明:"></a>配置前的说明:</h3><blockquote>
<ul>
<li>Hexo的_config.yml的储存位置: blog/_config.yml;</li>
<li>在改动配置前,请务必保存一份原始配置,确保出现故障可及时还原;</li>
<li>在配置文件时,冒号后面一定要加一个空格才能识别;</li>
<li>为方便对配置进行二次设置,可使用<code>#</code>对配置内容进行注释; </li>
<li>参考我在下面的注释,可帮助各位理解Hexo中<code>_config.yml</code>文件的配置;<!--一个句子后加两个空格换行有效,机智 -->
</li>
</ul>
</blockquote>
<h3 id="我的配置如下"><a href="#我的配置如下" class="headerlink" title="我的配置如下"></a>我的配置如下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> Hexo Configuration 配置文件</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/configuration.html</span></span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Source: https://github.com/hexojs/hexo/</span></span></div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Site 网站标题</span></div><div class="line">title: 杜若喃呢</div><div class="line"><span class="meta">#</span><span class="bash"> 网站副标题</span></div><div class="line">subtitle: 山中人兮芳杜若</div><div class="line"><span class="meta">#</span><span class="bash"> 网站描述</span></div><div class="line">description: Life is a gift,never take it for granted.</div><div class="line"><span class="meta">#</span><span class="bash"> 网站作者</span></div><div class="line">author: Xiangyu Kong</div><div class="line"><span class="meta">#</span><span class="bash"> 网站语言:需要主题支持</span></div><div class="line">language: zh-Hans</div><div class="line"><span class="meta">#</span><span class="bash"> 时区,默认电脑本地时区</span></div><div class="line">timezone: Asia/Shanghai</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> URL 网址</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> 网址</span></div><div class="line">url: http://duruonanni.github.io</div><div class="line"><span class="meta">#</span><span class="bash"> 网站根目录.如果网站本身就在根目录下(比如我这样),不管他</span></div><div class="line">root: /</div><div class="line"><span class="meta">#</span><span class="bash"> 网站生成文件格式</span></div><div class="line">permalink: blog/:title/:year:month:day/</div><div class="line">permalink_defaults:</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Directory 配置目录名(通常没必要修改)</span></div><div class="line"><span class="meta">#</span><span class="bash"> 资源文件夹，放在里面的文件会上传到github中</span></div><div class="line">source_dir: source</div><div class="line"><span class="meta">#</span><span class="bash"> 公共文件夹，存放生成的静态文件</span></div><div class="line">public_dir: public</div><div class="line"><span class="meta">#</span><span class="bash"> 标签文件夹，默认是tags.实际存放在<span class="built_in">source</span>/tags中</span></div><div class="line">tag_dir: tags</div><div class="line"><span class="meta">#</span><span class="bash"> 档案文件夹，默认是archives</span></div><div class="line">archive_dir: archives</div><div class="line"><span class="meta">#</span><span class="bash"> 类别文件夹，默认是categories.实际存放在<span class="built_in">source</span>/categories中</span></div><div class="line">category_dir: categories</div><div class="line"><span class="meta">#</span><span class="bash"> 代码文件夹，默认是downloads/code</span></div><div class="line">code_dir: downloads/code</div><div class="line"><span class="meta">#</span><span class="bash"> 语言文件夹,默认跟language相同</span></div><div class="line">i18n_dir: :lang</div><div class="line"><span class="meta">#</span><span class="bash"> 不需要渲染的文件,可使用glob表达式来匹配路径。</span></div><div class="line">skip_render: [Readme.md]</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Writing 文章内容</span></div><div class="line"><span class="meta">#</span><span class="bash"> File name of new posts 新文章名称</span></div><div class="line">new_post_name: :title.md</div><div class="line"><span class="meta">#</span><span class="bash"> 默认布局 除了post外,Hexo默认还支持page和draft布局</span></div><div class="line">default_layout: post</div><div class="line"><span class="meta">#</span><span class="bash"> Transform title into titlecase 把标题转换为 titlecase</span></div><div class="line">titlecase: false</div><div class="line"><span class="meta">#</span><span class="bash"> 新标签打开方式,<span class="literal">true</span>是打开一个外部链接</span></div><div class="line">external_link: true</div><div class="line"><span class="meta">#</span><span class="bash"> 转换文件名,值为0不转,1小写,2大写</span></div><div class="line">filename_case: 0</div><div class="line"><span class="meta">#</span><span class="bash"> 显示草稿</span></div><div class="line">render_drafts: false</div><div class="line"><span class="meta">#</span><span class="bash"> 启用 Asset 文件夹</span></div><div class="line">post_asset_folder: false</div><div class="line"><span class="meta">#</span><span class="bash"> 把链接改为与根目录的相对位址</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 默认情况下，Hexo生成的超链接都是绝对地址.通常情况下，建议如此</span></span></div><div class="line">relative_link: false</div><div class="line"><span class="meta">#</span><span class="bash"> 显示未来的文章</span></div><div class="line">future: true</div><div class="line"><span class="meta">#</span><span class="bash"> 代码高亮</span></div><div class="line">highlight:</div><div class="line">  enable: true</div><div class="line">  line_number: true</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Category &amp; Tag 分类 &amp; 标签</span></div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">tag_map:</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Date / Time format 日期 / 时间格式 </span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Hexo 使用 Moment.js 来解析和显示时间</span></span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Hexo uses Moment.js to parse and display date</span></span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># You can customize the date format as defined in</span></span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># http://momentjs.com/docs/#/displaying/format/</span></span></div><div class="line">date_format: YYYY-MM-DD</div><div class="line">time_format: HH:mm:ss</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Pagination 分页</span></div><div class="line"><span class="meta">#</span><span class="bash"> 0则关闭分页功能,全部在1页</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Set per_page to 0 to disable pagination 设置每页显示文章量</span></span></div><div class="line">per_page: 10</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 分页路径，在public中可以看到</span></span></div><div class="line">pagination_dir: page</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Extensions 扩展插件</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></div><div class="line">plugins: </div><div class="line"><span class="meta">#</span><span class="bash"> 生成RSS的插件</span></div><div class="line"> -hexo-generator-feed</div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> 主题</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></div><div class="line"><span class="meta">#</span><span class="bash">theme: <span class="literal">false</span> <span class="comment">#禁用主题</span></span></div><div class="line"><span class="meta">#</span><span class="bash">theme: landscape <span class="comment">#默认主题</span></span></div><div class="line">theme: next</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> Deployment</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 发布</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line"><span class="meta">  #</span><span class="bash"> 部署到github上</span></div><div class="line">  repository: https://github.com/duruonanni/duruonanni.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<h2 id="三-Hexo常用指令"><a href="#三-Hexo常用指令" class="headerlink" title="三. Hexo常用指令"></a>三. Hexo常用指令</h2><p>ATT:  </p>
<ul>
<li>以下指令建议在<code>Git bash</code>中操作,不建议用CMD;  </li>
</ul>
<h3 id="1-init-初始化一个网站"><a href="#1-init-初始化一个网站" class="headerlink" title="1. init # 初始化一个网站"></a>1. init # 初始化一个网站</h3><blockquote>
<p>语法:     <code>hexo init [folder]</code><br>说明:     <code>folder</code> 是网站在本地储存使用的文件夹名,我用的是blog<br>ATT:  </p>
<ul>
<li>一旦配置好_config.yml文件,请不要轻易在blog文件夹使用该命令,这会导致配置文件重置;</li>
<li>在操作中输入folder内容时不用加<code>[]</code>符号,下面的所有指令中的<code>[]</code>,<code>&lt;&gt;</code>也不需要加;</li>
<li>如果需要输入的指令内容(eg: 文章名)包含空格,可用<code>-</code>替代或将所有内容用<code>&#39;&#39;</code>包起来;  </li>
<li>使用此语法前,请先将’Git bash’定位到该用于存储blog文件的文件夹中</li>
</ul>
</blockquote>
<h3 id="2-generate-生成网站的静态文件"><a href="#2-generate-生成网站的静态文件" class="headerlink" title="2. generate # 生成网站的静态文件"></a>2. generate # 生成网站的静态文件</h3><blockquote>
<p>语法:     <code>hexo generate</code><br>说明:     可简写成 <code>hexo g</code></p>
</blockquote>
<h3 id="3-new-新建文章"><a href="#3-new-新建文章" class="headerlink" title="3. new # 新建文章"></a>3. new # 新建文章</h3><blockquote>
<p>语法:     <code>hexo new &lt;title&gt;</code><br>说明: </p>
<ul>
<li><code>title</code>写文章名</li>
<li>此语法默认会将新建的文章放到<code>blog--souce--_posts</code>文件夹中,你可以在新建的文章中使用Markdown语法编辑内容,最终<code>_posts</code>文件夹中的文章会默认以时间顺序发布到你的网站上面.<br>ATT: </li>
<li>Hexo中文章的文本格式需要是Markdown(后缀名<code>.md</code>)</li>
<li>关于Markdown的常用语法,可参见我近期的总结<a href="https://duruonanni.github.io/blog/Markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/20170525/" title="Markdown" target="_blank" rel="external">Markdown语法练习</a></li>
<li>这里更推荐以<code>发表草稿</code>的方式新建文章,具体方法如下:  <blockquote>
<ul>
<li>使用语法: <code>hexo new draft &lt;title&gt;</code> 将文章新建到<em>blog–souce–_drafts</em>文件夹中,你可以在此处对文章进行编辑.待确认发布时,使用语法:<code>hexo publish draft &lt;filename&gt;</code>,可将选定的文章传到<code>_posts</code>文件夹.  </li>
<li>这样的好处是,可以先给文章打好草稿,直接推送写好的成品.可避免未写完的文章放到电脑其他位置弄乱弄丢.(不建议直接在<code>_posts</code>文件夹中编辑文章)  </li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4-server-启动服务器"><a href="#4-server-启动服务器" class="headerlink" title="4. server # 启动服务器"></a>4. server # 启动服务器</h3><blockquote>
<p>语法:     <code>hexo server</code> 可简写成 <code>hexo s</code><br>说明:     启动服务器,使站点可通过浏览器,在网址:<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>  预览站点.按<strong>ctrl+c</strong>结束预览<br>ATT:</p>
<ul>
<li>启用此语法后,能看到站点中你事先编辑好的内容,此时改变blog文件夹中内容不会在站点内体现,需要退出后再次启动才能看到变动.</li>
<li>为实时对站点内容进行调整,可使用语法:<code>hexo server --debug</code>进入本地调试模式,并将调试日志写入<strong>debug.log</strong>文件中.此时做出的所有调整都能在网站上动态体现.</li>
</ul>
</blockquote>
<h3 id="5-deoloy-部署网站"><a href="#5-deoloy-部署网站" class="headerlink" title="5. deoloy # 部署网站"></a>5. deoloy # 部署网站</h3><blockquote>
<p>语法:     <code>hexo deploy</code> 可简写成 <code>hexo d</code><br>说明:     将站点内容部署到服务器上,使所有人能通过域名访问新发布的文章<br>ATT:     建议使用 ‘hexo d -g’ 语法,在部署之前预先生成静态文件.  </p>
</blockquote>
<p>至此:完~🐱‍👤 </p>
<p><img src="http://storage.live.com/items/AEE68C12565C1619!174679:/YuYu Hakusho.jpg?authkey=AJoh90nl3u6Wj4U" alt="YoYo hakuso"></p>
<!--参考:(不会出现在正文里)-->
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在之前的话&quot;&gt;&lt;a href=&quot;#写在之前的话&quot; class=&quot;headerlink&quot; title=&quot;写在之前的话&quot;&gt;&lt;/a&gt;写在之前的话&lt;/h2&gt;&lt;p&gt;本文主要结合我建站时的经历,对配置Hexo的&lt;code&gt;_config.yml&lt;/code&gt;文件配置说明,以
    
    </summary>
    
      <category term="教程" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="hexo" scheme="http://duruonanni.com/categories/%E6%95%99%E7%A8%8B/hexo/"/>
    
    
      <category term="教程" scheme="http://duruonanni.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://duruonanni.com/hello-world/20170504.html"/>
    <id>http://duruonanni.com/hello-world/20170504.html</id>
    <published>2017-05-04T14:50:41.679Z</published>
    <updated>2017-05-08T11:13:08.181Z</updated>
    
    <content type="html"><![CDATA[<p>In C# we say:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main(<span class="keyword">string</span>[] args)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">Console</span>.Writeline(<span class="string">"Hello world"</span>);</div><div class="line">	<span class="built_in">Console</span>.Readkey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>In HTML we say:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">	Hello world</div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">htme</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;In C# we say:&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;
    
    </summary>
    
    
  </entry>
  
</feed>
